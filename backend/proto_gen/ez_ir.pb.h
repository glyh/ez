// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: ez_ir.proto
// Protobuf C++ Version: 5.28.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_ez_5fir_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_ez_5fir_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_ez_5fir_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_ez_5fir_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_ez_5fir_2eproto;
namespace ez_proto {
class Definition;
struct DefinitionDefaultTypeInternal;
extern DefinitionDefaultTypeInternal _Definition_default_instance_;
class Definition_EzTypedParam;
struct Definition_EzTypedParamDefaultTypeInternal;
extern Definition_EzTypedParamDefaultTypeInternal _Definition_EzTypedParam_default_instance_;
class Expr;
struct ExprDefaultTypeInternal;
extern ExprDefaultTypeInternal _Expr_default_instance_;
class Expr_Binary;
struct Expr_BinaryDefaultTypeInternal;
extern Expr_BinaryDefaultTypeInternal _Expr_Binary_default_instance_;
class Expr_Call;
struct Expr_CallDefaultTypeInternal;
extern Expr_CallDefaultTypeInternal _Expr_Call_default_instance_;
class EzType;
struct EzTypeDefaultTypeInternal;
extern EzTypeDefaultTypeInternal _EzType_default_instance_;
class Program;
struct ProgramDefaultTypeInternal;
extern ProgramDefaultTypeInternal _Program_default_instance_;
class Statement;
struct StatementDefaultTypeInternal;
extern StatementDefaultTypeInternal _Statement_default_instance_;
class Statement_Assign;
struct Statement_AssignDefaultTypeInternal;
extern Statement_AssignDefaultTypeInternal _Statement_Assign_default_instance_;
class Statement_Block;
struct Statement_BlockDefaultTypeInternal;
extern Statement_BlockDefaultTypeInternal _Statement_Block_default_instance_;
class Statement_Declaration;
struct Statement_DeclarationDefaultTypeInternal;
extern Statement_DeclarationDefaultTypeInternal _Statement_Declaration_default_instance_;
class Statement_If;
struct Statement_IfDefaultTypeInternal;
extern Statement_IfDefaultTypeInternal _Statement_If_default_instance_;
class Statement_While;
struct Statement_WhileDefaultTypeInternal;
extern Statement_WhileDefaultTypeInternal _Statement_While_default_instance_;
class Value;
struct ValueDefaultTypeInternal;
extern ValueDefaultTypeInternal _Value_default_instance_;
class Value_Unit;
struct Value_UnitDefaultTypeInternal;
extern Value_UnitDefaultTypeInternal _Value_Unit_default_instance_;
}  // namespace ez_proto
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace ez_proto {
enum EzType_NonPtr : int {
  EzType_NonPtr_UNIT = 0,
  EzType_NonPtr_I64 = 1,
  EzType_NonPtr_STR = 2,
  EzType_NonPtr_F64 = 3,
  EzType_NonPtr_BOOL = 4,
};

bool EzType_NonPtr_IsValid(int value);
extern const uint32_t EzType_NonPtr_internal_data_[];
constexpr EzType_NonPtr EzType_NonPtr_NonPtr_MIN = static_cast<EzType_NonPtr>(0);
constexpr EzType_NonPtr EzType_NonPtr_NonPtr_MAX = static_cast<EzType_NonPtr>(4);
constexpr int EzType_NonPtr_NonPtr_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
EzType_NonPtr_descriptor();
template <typename T>
const std::string& EzType_NonPtr_Name(T value) {
  static_assert(std::is_same<T, EzType_NonPtr>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to NonPtr_Name().");
  return EzType_NonPtr_Name(static_cast<EzType_NonPtr>(value));
}
template <>
inline const std::string& EzType_NonPtr_Name(EzType_NonPtr value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EzType_NonPtr_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool EzType_NonPtr_Parse(absl::string_view name, EzType_NonPtr* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EzType_NonPtr>(
      EzType_NonPtr_descriptor(), name, value);
}
enum Expr_Binary_BinOp : int {
  Expr_Binary_BinOp_ADD = 0,
  Expr_Binary_BinOp_SUB = 1,
  Expr_Binary_BinOp_MUL = 2,
  Expr_Binary_BinOp_DIV = 3,
  Expr_Binary_BinOp_MOD = 4,
  Expr_Binary_BinOp_EQ = 5,
  Expr_Binary_BinOp_NOTEQ = 6,
  Expr_Binary_BinOp_LESSTHAN = 7,
  Expr_Binary_BinOp_LESSEQ = 8,
  Expr_Binary_BinOp_GREATERTHAN = 9,
  Expr_Binary_BinOp_GREATEREQ = 10,
  Expr_Binary_BinOp_LAND = 11,
  Expr_Binary_BinOp_LOR = 12,
};

bool Expr_Binary_BinOp_IsValid(int value);
extern const uint32_t Expr_Binary_BinOp_internal_data_[];
constexpr Expr_Binary_BinOp Expr_Binary_BinOp_BinOp_MIN = static_cast<Expr_Binary_BinOp>(0);
constexpr Expr_Binary_BinOp Expr_Binary_BinOp_BinOp_MAX = static_cast<Expr_Binary_BinOp>(12);
constexpr int Expr_Binary_BinOp_BinOp_ARRAYSIZE = 12 + 1;
const ::google::protobuf::EnumDescriptor*
Expr_Binary_BinOp_descriptor();
template <typename T>
const std::string& Expr_Binary_BinOp_Name(T value) {
  static_assert(std::is_same<T, Expr_Binary_BinOp>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to BinOp_Name().");
  return Expr_Binary_BinOp_Name(static_cast<Expr_Binary_BinOp>(value));
}
template <>
inline const std::string& Expr_Binary_BinOp_Name(Expr_Binary_BinOp value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Expr_Binary_BinOp_descriptor,
                                                 0, 12>(
      static_cast<int>(value));
}
inline bool Expr_Binary_BinOp_Parse(absl::string_view name, Expr_Binary_BinOp* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Expr_Binary_BinOp>(
      Expr_Binary_BinOp_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Value_Unit final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:ez_proto.Value.Unit) */ {
 public:
  inline Value_Unit() : Value_Unit(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Value_Unit(
      ::google::protobuf::internal::ConstantInitialized);

  inline Value_Unit(const Value_Unit& from) : Value_Unit(nullptr, from) {}
  inline Value_Unit(Value_Unit&& from) noexcept
      : Value_Unit(nullptr, std::move(from)) {}
  inline Value_Unit& operator=(const Value_Unit& from) {
    CopyFrom(from);
    return *this;
  }
  inline Value_Unit& operator=(Value_Unit&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Value_Unit& default_instance() {
    return *internal_default_instance();
  }
  static inline const Value_Unit* internal_default_instance() {
    return reinterpret_cast<const Value_Unit*>(
        &_Value_Unit_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Value_Unit& a, Value_Unit& b) { a.Swap(&b); }
  inline void Swap(Value_Unit* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Value_Unit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Value_Unit* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Value_Unit>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Value_Unit& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Value_Unit& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ez_proto.Value.Unit"; }

 protected:
  explicit Value_Unit(::google::protobuf::Arena* arena);
  Value_Unit(::google::protobuf::Arena* arena, const Value_Unit& from);
  Value_Unit(::google::protobuf::Arena* arena, Value_Unit&& from) noexcept
      : Value_Unit(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:ez_proto.Value.Unit)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Value_Unit_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Value_Unit& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_ez_5fir_2eproto;
};
// -------------------------------------------------------------------

class EzType final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ez_proto.EzType) */ {
 public:
  inline EzType() : EzType(nullptr) {}
  ~EzType() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EzType(
      ::google::protobuf::internal::ConstantInitialized);

  inline EzType(const EzType& from) : EzType(nullptr, from) {}
  inline EzType(EzType&& from) noexcept
      : EzType(nullptr, std::move(from)) {}
  inline EzType& operator=(const EzType& from) {
    CopyFrom(from);
    return *this;
  }
  inline EzType& operator=(EzType&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EzType& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kNonPtr = 1,
    kPtr = 2,
    KIND_NOT_SET = 0,
  };
  static inline const EzType* internal_default_instance() {
    return reinterpret_cast<const EzType*>(
        &_EzType_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(EzType& a, EzType& b) { a.Swap(&b); }
  inline void Swap(EzType* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EzType* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EzType* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<EzType>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EzType& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EzType& from) { EzType::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EzType* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ez_proto.EzType"; }

 protected:
  explicit EzType(::google::protobuf::Arena* arena);
  EzType(::google::protobuf::Arena* arena, const EzType& from);
  EzType(::google::protobuf::Arena* arena, EzType&& from) noexcept
      : EzType(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using NonPtr = EzType_NonPtr;
  static constexpr NonPtr UNIT = EzType_NonPtr_UNIT;
  static constexpr NonPtr I64 = EzType_NonPtr_I64;
  static constexpr NonPtr STR = EzType_NonPtr_STR;
  static constexpr NonPtr F64 = EzType_NonPtr_F64;
  static constexpr NonPtr BOOL = EzType_NonPtr_BOOL;
  static inline bool NonPtr_IsValid(int value) {
    return EzType_NonPtr_IsValid(value);
  }
  static constexpr NonPtr NonPtr_MIN = EzType_NonPtr_NonPtr_MIN;
  static constexpr NonPtr NonPtr_MAX = EzType_NonPtr_NonPtr_MAX;
  static constexpr int NonPtr_ARRAYSIZE = EzType_NonPtr_NonPtr_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* NonPtr_descriptor() {
    return EzType_NonPtr_descriptor();
  }
  template <typename T>
  static inline const std::string& NonPtr_Name(T value) {
    return EzType_NonPtr_Name(value);
  }
  static inline bool NonPtr_Parse(absl::string_view name, NonPtr* value) {
    return EzType_NonPtr_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kNonPtrFieldNumber = 1,
    kPtrFieldNumber = 2,
  };
  // .ez_proto.EzType.NonPtr non_ptr = 1;
  bool has_non_ptr() const;
  void clear_non_ptr() ;
  ::ez_proto::EzType_NonPtr non_ptr() const;
  void set_non_ptr(::ez_proto::EzType_NonPtr value);

  private:
  ::ez_proto::EzType_NonPtr _internal_non_ptr() const;
  void _internal_set_non_ptr(::ez_proto::EzType_NonPtr value);

  public:
  // .ez_proto.EzType ptr = 2;
  bool has_ptr() const;
  private:
  bool _internal_has_ptr() const;

  public:
  void clear_ptr() ;
  const ::ez_proto::EzType& ptr() const;
  PROTOBUF_NODISCARD ::ez_proto::EzType* release_ptr();
  ::ez_proto::EzType* mutable_ptr();
  void set_allocated_ptr(::ez_proto::EzType* value);
  void unsafe_arena_set_allocated_ptr(::ez_proto::EzType* value);
  ::ez_proto::EzType* unsafe_arena_release_ptr();

  private:
  const ::ez_proto::EzType& _internal_ptr() const;
  ::ez_proto::EzType* _internal_mutable_ptr();

  public:
  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:ez_proto.EzType)
 private:
  class _Internal;
  void set_has_non_ptr();
  void set_has_ptr();
  inline bool has_kind() const;
  inline void clear_has_kind();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_EzType_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const EzType& from_msg);
    union KindUnion {
      constexpr KindUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      int non_ptr_;
      ::ez_proto::EzType* ptr_;
    } kind_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ez_5fir_2eproto;
};
// -------------------------------------------------------------------

class Value final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ez_proto.Value) */ {
 public:
  inline Value() : Value(nullptr) {}
  ~Value() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Value(
      ::google::protobuf::internal::ConstantInitialized);

  inline Value(const Value& from) : Value(nullptr, from) {}
  inline Value(Value&& from) noexcept
      : Value(nullptr, std::move(from)) {}
  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }
  inline Value& operator=(Value&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Value& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kUnitVal = 1,
    kI64Val = 2,
    kStrVal = 3,
    kF64Val = 4,
    kBoolVal = 5,
    KIND_NOT_SET = 0,
  };
  static inline const Value* internal_default_instance() {
    return reinterpret_cast<const Value*>(
        &_Value_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Value& a, Value& b) { a.Swap(&b); }
  inline void Swap(Value* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Value* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Value* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Value>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Value& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Value& from) { Value::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Value* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ez_proto.Value"; }

 protected:
  explicit Value(::google::protobuf::Arena* arena);
  Value(::google::protobuf::Arena* arena, const Value& from);
  Value(::google::protobuf::Arena* arena, Value&& from) noexcept
      : Value(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Unit = Value_Unit;

  // accessors -------------------------------------------------------
  enum : int {
    kUnitValFieldNumber = 1,
    kI64ValFieldNumber = 2,
    kStrValFieldNumber = 3,
    kF64ValFieldNumber = 4,
    kBoolValFieldNumber = 5,
  };
  // .ez_proto.Value.Unit unit_val = 1;
  bool has_unit_val() const;
  private:
  bool _internal_has_unit_val() const;

  public:
  void clear_unit_val() ;
  const ::ez_proto::Value_Unit& unit_val() const;
  PROTOBUF_NODISCARD ::ez_proto::Value_Unit* release_unit_val();
  ::ez_proto::Value_Unit* mutable_unit_val();
  void set_allocated_unit_val(::ez_proto::Value_Unit* value);
  void unsafe_arena_set_allocated_unit_val(::ez_proto::Value_Unit* value);
  ::ez_proto::Value_Unit* unsafe_arena_release_unit_val();

  private:
  const ::ez_proto::Value_Unit& _internal_unit_val() const;
  ::ez_proto::Value_Unit* _internal_mutable_unit_val();

  public:
  // int64 i64_val = 2;
  bool has_i64_val() const;
  void clear_i64_val() ;
  ::int64_t i64_val() const;
  void set_i64_val(::int64_t value);

  private:
  ::int64_t _internal_i64_val() const;
  void _internal_set_i64_val(::int64_t value);

  public:
  // string str_val = 3;
  bool has_str_val() const;
  void clear_str_val() ;
  const std::string& str_val() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_str_val(Arg_&& arg, Args_... args);
  std::string* mutable_str_val();
  PROTOBUF_NODISCARD std::string* release_str_val();
  void set_allocated_str_val(std::string* value);

  private:
  const std::string& _internal_str_val() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_str_val(
      const std::string& value);
  std::string* _internal_mutable_str_val();

  public:
  // double f64_val = 4;
  bool has_f64_val() const;
  void clear_f64_val() ;
  double f64_val() const;
  void set_f64_val(double value);

  private:
  double _internal_f64_val() const;
  void _internal_set_f64_val(double value);

  public:
  // bool bool_val = 5;
  bool has_bool_val() const;
  void clear_bool_val() ;
  bool bool_val() const;
  void set_bool_val(bool value);

  private:
  bool _internal_bool_val() const;
  void _internal_set_bool_val(bool value);

  public:
  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:ez_proto.Value)
 private:
  class _Internal;
  void set_has_unit_val();
  void set_has_i64_val();
  void set_has_str_val();
  void set_has_f64_val();
  void set_has_bool_val();
  inline bool has_kind() const;
  inline void clear_has_kind();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 5, 1,
      30, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Value_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Value& from_msg);
    union KindUnion {
      constexpr KindUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::ez_proto::Value_Unit* unit_val_;
      ::int64_t i64_val_;
      ::google::protobuf::internal::ArenaStringPtr str_val_;
      double f64_val_;
      bool bool_val_;
    } kind_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ez_5fir_2eproto;
};
// -------------------------------------------------------------------

class Definition_EzTypedParam final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ez_proto.Definition.EzTypedParam) */ {
 public:
  inline Definition_EzTypedParam() : Definition_EzTypedParam(nullptr) {}
  ~Definition_EzTypedParam() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Definition_EzTypedParam(
      ::google::protobuf::internal::ConstantInitialized);

  inline Definition_EzTypedParam(const Definition_EzTypedParam& from) : Definition_EzTypedParam(nullptr, from) {}
  inline Definition_EzTypedParam(Definition_EzTypedParam&& from) noexcept
      : Definition_EzTypedParam(nullptr, std::move(from)) {}
  inline Definition_EzTypedParam& operator=(const Definition_EzTypedParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline Definition_EzTypedParam& operator=(Definition_EzTypedParam&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Definition_EzTypedParam& default_instance() {
    return *internal_default_instance();
  }
  static inline const Definition_EzTypedParam* internal_default_instance() {
    return reinterpret_cast<const Definition_EzTypedParam*>(
        &_Definition_EzTypedParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(Definition_EzTypedParam& a, Definition_EzTypedParam& b) { a.Swap(&b); }
  inline void Swap(Definition_EzTypedParam* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Definition_EzTypedParam* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Definition_EzTypedParam* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Definition_EzTypedParam>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Definition_EzTypedParam& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Definition_EzTypedParam& from) { Definition_EzTypedParam::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Definition_EzTypedParam* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ez_proto.Definition.EzTypedParam"; }

 protected:
  explicit Definition_EzTypedParam(::google::protobuf::Arena* arena);
  Definition_EzTypedParam(::google::protobuf::Arena* arena, const Definition_EzTypedParam& from);
  Definition_EzTypedParam(::google::protobuf::Arena* arena, Definition_EzTypedParam&& from) noexcept
      : Definition_EzTypedParam(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 2,
    kParamTypeFieldNumber = 1,
  };
  // required string name = 2;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // required .ez_proto.EzType param_type = 1;
  bool has_param_type() const;
  void clear_param_type() ;
  const ::ez_proto::EzType& param_type() const;
  PROTOBUF_NODISCARD ::ez_proto::EzType* release_param_type();
  ::ez_proto::EzType* mutable_param_type();
  void set_allocated_param_type(::ez_proto::EzType* value);
  void unsafe_arena_set_allocated_param_type(::ez_proto::EzType* value);
  ::ez_proto::EzType* unsafe_arena_release_param_type();

  private:
  const ::ez_proto::EzType& _internal_param_type() const;
  ::ez_proto::EzType* _internal_mutable_param_type();

  public:
  // @@protoc_insertion_point(class_scope:ez_proto.Definition.EzTypedParam)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      45, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Definition_EzTypedParam_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Definition_EzTypedParam& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::ez_proto::EzType* param_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ez_5fir_2eproto;
};
// -------------------------------------------------------------------

class Expr final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ez_proto.Expr) */ {
 public:
  inline Expr() : Expr(nullptr) {}
  ~Expr() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expr(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expr(const Expr& from) : Expr(nullptr, from) {}
  inline Expr(Expr&& from) noexcept
      : Expr(nullptr, std::move(from)) {}
  inline Expr& operator=(const Expr& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expr& operator=(Expr&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expr& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kBinary = 1,
    kValue = 2,
    kVariable = 3,
    kCall = 4,
    KIND_NOT_SET = 0,
  };
  static inline const Expr* internal_default_instance() {
    return reinterpret_cast<const Expr*>(
        &_Expr_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(Expr& a, Expr& b) { a.Swap(&b); }
  inline void Swap(Expr* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expr* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expr* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Expr>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expr& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expr& from) { Expr::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Expr* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ez_proto.Expr"; }

 protected:
  explicit Expr(::google::protobuf::Arena* arena);
  Expr(::google::protobuf::Arena* arena, const Expr& from);
  Expr(::google::protobuf::Arena* arena, Expr&& from) noexcept
      : Expr(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Binary = Expr_Binary;
  using Call = Expr_Call;

  // accessors -------------------------------------------------------
  enum : int {
    kExprTypeFieldNumber = 7,
    kBinaryFieldNumber = 1,
    kValueFieldNumber = 2,
    kVariableFieldNumber = 3,
    kCallFieldNumber = 4,
  };
  // required .ez_proto.EzType expr_type = 7;
  bool has_expr_type() const;
  void clear_expr_type() ;
  const ::ez_proto::EzType& expr_type() const;
  PROTOBUF_NODISCARD ::ez_proto::EzType* release_expr_type();
  ::ez_proto::EzType* mutable_expr_type();
  void set_allocated_expr_type(::ez_proto::EzType* value);
  void unsafe_arena_set_allocated_expr_type(::ez_proto::EzType* value);
  ::ez_proto::EzType* unsafe_arena_release_expr_type();

  private:
  const ::ez_proto::EzType& _internal_expr_type() const;
  ::ez_proto::EzType* _internal_mutable_expr_type();

  public:
  // .ez_proto.Expr.Binary binary = 1;
  bool has_binary() const;
  private:
  bool _internal_has_binary() const;

  public:
  void clear_binary() ;
  const ::ez_proto::Expr_Binary& binary() const;
  PROTOBUF_NODISCARD ::ez_proto::Expr_Binary* release_binary();
  ::ez_proto::Expr_Binary* mutable_binary();
  void set_allocated_binary(::ez_proto::Expr_Binary* value);
  void unsafe_arena_set_allocated_binary(::ez_proto::Expr_Binary* value);
  ::ez_proto::Expr_Binary* unsafe_arena_release_binary();

  private:
  const ::ez_proto::Expr_Binary& _internal_binary() const;
  ::ez_proto::Expr_Binary* _internal_mutable_binary();

  public:
  // .ez_proto.Value value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;

  public:
  void clear_value() ;
  const ::ez_proto::Value& value() const;
  PROTOBUF_NODISCARD ::ez_proto::Value* release_value();
  ::ez_proto::Value* mutable_value();
  void set_allocated_value(::ez_proto::Value* value);
  void unsafe_arena_set_allocated_value(::ez_proto::Value* value);
  ::ez_proto::Value* unsafe_arena_release_value();

  private:
  const ::ez_proto::Value& _internal_value() const;
  ::ez_proto::Value* _internal_mutable_value();

  public:
  // string variable = 3;
  bool has_variable() const;
  void clear_variable() ;
  const std::string& variable() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_variable(Arg_&& arg, Args_... args);
  std::string* mutable_variable();
  PROTOBUF_NODISCARD std::string* release_variable();
  void set_allocated_variable(std::string* value);

  private:
  const std::string& _internal_variable() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_variable(
      const std::string& value);
  std::string* _internal_mutable_variable();

  public:
  // .ez_proto.Expr.Call call = 4;
  bool has_call() const;
  private:
  bool _internal_has_call() const;

  public:
  void clear_call() ;
  const ::ez_proto::Expr_Call& call() const;
  PROTOBUF_NODISCARD ::ez_proto::Expr_Call* release_call();
  ::ez_proto::Expr_Call* mutable_call();
  void set_allocated_call(::ez_proto::Expr_Call* value);
  void unsafe_arena_set_allocated_call(::ez_proto::Expr_Call* value);
  ::ez_proto::Expr_Call* unsafe_arena_release_call();

  private:
  const ::ez_proto::Expr_Call& _internal_call() const;
  ::ez_proto::Expr_Call* _internal_mutable_call();

  public:
  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:ez_proto.Expr)
 private:
  class _Internal;
  void set_has_binary();
  void set_has_value();
  void set_has_variable();
  void set_has_call();
  inline bool has_kind() const;
  inline void clear_has_kind();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 5, 4,
      30, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Expr_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expr& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::ez_proto::EzType* expr_type_;
    union KindUnion {
      constexpr KindUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::ez_proto::Expr_Binary* binary_;
      ::ez_proto::Value* value_;
      ::google::protobuf::internal::ArenaStringPtr variable_;
      ::ez_proto::Expr_Call* call_;
    } kind_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ez_5fir_2eproto;
};
// -------------------------------------------------------------------

class Expr_Binary final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ez_proto.Expr.Binary) */ {
 public:
  inline Expr_Binary() : Expr_Binary(nullptr) {}
  ~Expr_Binary() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expr_Binary(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expr_Binary(const Expr_Binary& from) : Expr_Binary(nullptr, from) {}
  inline Expr_Binary(Expr_Binary&& from) noexcept
      : Expr_Binary(nullptr, std::move(from)) {}
  inline Expr_Binary& operator=(const Expr_Binary& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expr_Binary& operator=(Expr_Binary&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expr_Binary& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expr_Binary* internal_default_instance() {
    return reinterpret_cast<const Expr_Binary*>(
        &_Expr_Binary_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(Expr_Binary& a, Expr_Binary& b) { a.Swap(&b); }
  inline void Swap(Expr_Binary* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expr_Binary* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expr_Binary* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Expr_Binary>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expr_Binary& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expr_Binary& from) { Expr_Binary::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Expr_Binary* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ez_proto.Expr.Binary"; }

 protected:
  explicit Expr_Binary(::google::protobuf::Arena* arena);
  Expr_Binary(::google::protobuf::Arena* arena, const Expr_Binary& from);
  Expr_Binary(::google::protobuf::Arena* arena, Expr_Binary&& from) noexcept
      : Expr_Binary(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using BinOp = Expr_Binary_BinOp;
  static constexpr BinOp ADD = Expr_Binary_BinOp_ADD;
  static constexpr BinOp SUB = Expr_Binary_BinOp_SUB;
  static constexpr BinOp MUL = Expr_Binary_BinOp_MUL;
  static constexpr BinOp DIV = Expr_Binary_BinOp_DIV;
  static constexpr BinOp MOD = Expr_Binary_BinOp_MOD;
  static constexpr BinOp EQ = Expr_Binary_BinOp_EQ;
  static constexpr BinOp NOTEQ = Expr_Binary_BinOp_NOTEQ;
  static constexpr BinOp LESSTHAN = Expr_Binary_BinOp_LESSTHAN;
  static constexpr BinOp LESSEQ = Expr_Binary_BinOp_LESSEQ;
  static constexpr BinOp GREATERTHAN = Expr_Binary_BinOp_GREATERTHAN;
  static constexpr BinOp GREATEREQ = Expr_Binary_BinOp_GREATEREQ;
  static constexpr BinOp LAND = Expr_Binary_BinOp_LAND;
  static constexpr BinOp LOR = Expr_Binary_BinOp_LOR;
  static inline bool BinOp_IsValid(int value) {
    return Expr_Binary_BinOp_IsValid(value);
  }
  static constexpr BinOp BinOp_MIN = Expr_Binary_BinOp_BinOp_MIN;
  static constexpr BinOp BinOp_MAX = Expr_Binary_BinOp_BinOp_MAX;
  static constexpr int BinOp_ARRAYSIZE = Expr_Binary_BinOp_BinOp_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* BinOp_descriptor() {
    return Expr_Binary_BinOp_descriptor();
  }
  template <typename T>
  static inline const std::string& BinOp_Name(T value) {
    return Expr_Binary_BinOp_Name(value);
  }
  static inline bool BinOp_Parse(absl::string_view name, BinOp* value) {
    return Expr_Binary_BinOp_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kLhsFieldNumber = 2,
    kRhsFieldNumber = 3,
    kOpFieldNumber = 1,
  };
  // required .ez_proto.Expr lhs = 2;
  bool has_lhs() const;
  void clear_lhs() ;
  const ::ez_proto::Expr& lhs() const;
  PROTOBUF_NODISCARD ::ez_proto::Expr* release_lhs();
  ::ez_proto::Expr* mutable_lhs();
  void set_allocated_lhs(::ez_proto::Expr* value);
  void unsafe_arena_set_allocated_lhs(::ez_proto::Expr* value);
  ::ez_proto::Expr* unsafe_arena_release_lhs();

  private:
  const ::ez_proto::Expr& _internal_lhs() const;
  ::ez_proto::Expr* _internal_mutable_lhs();

  public:
  // required .ez_proto.Expr rhs = 3;
  bool has_rhs() const;
  void clear_rhs() ;
  const ::ez_proto::Expr& rhs() const;
  PROTOBUF_NODISCARD ::ez_proto::Expr* release_rhs();
  ::ez_proto::Expr* mutable_rhs();
  void set_allocated_rhs(::ez_proto::Expr* value);
  void unsafe_arena_set_allocated_rhs(::ez_proto::Expr* value);
  ::ez_proto::Expr* unsafe_arena_release_rhs();

  private:
  const ::ez_proto::Expr& _internal_rhs() const;
  ::ez_proto::Expr* _internal_mutable_rhs();

  public:
  // required .ez_proto.Expr.Binary.BinOp op = 1;
  bool has_op() const;
  void clear_op() ;
  ::ez_proto::Expr_Binary_BinOp op() const;
  void set_op(::ez_proto::Expr_Binary_BinOp value);

  private:
  ::ez_proto::Expr_Binary_BinOp _internal_op() const;
  void _internal_set_op(::ez_proto::Expr_Binary_BinOp value);

  public:
  // @@protoc_insertion_point(class_scope:ez_proto.Expr.Binary)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Expr_Binary_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expr_Binary& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::ez_proto::Expr* lhs_;
    ::ez_proto::Expr* rhs_;
    int op_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ez_5fir_2eproto;
};
// -------------------------------------------------------------------

class Expr_Call final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ez_proto.Expr.Call) */ {
 public:
  inline Expr_Call() : Expr_Call(nullptr) {}
  ~Expr_Call() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expr_Call(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expr_Call(const Expr_Call& from) : Expr_Call(nullptr, from) {}
  inline Expr_Call(Expr_Call&& from) noexcept
      : Expr_Call(nullptr, std::move(from)) {}
  inline Expr_Call& operator=(const Expr_Call& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expr_Call& operator=(Expr_Call&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expr_Call& default_instance() {
    return *internal_default_instance();
  }
  static inline const Expr_Call* internal_default_instance() {
    return reinterpret_cast<const Expr_Call*>(
        &_Expr_Call_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(Expr_Call& a, Expr_Call& b) { a.Swap(&b); }
  inline void Swap(Expr_Call* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expr_Call* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expr_Call* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Expr_Call>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expr_Call& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expr_Call& from) { Expr_Call::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Expr_Call* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ez_proto.Expr.Call"; }

 protected:
  explicit Expr_Call(::google::protobuf::Arena* arena);
  Expr_Call(::google::protobuf::Arena* arena, const Expr_Call& from);
  Expr_Call(::google::protobuf::Arena* arena, Expr_Call&& from) noexcept
      : Expr_Call(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kArgsFieldNumber = 2,
    kCalleeFieldNumber = 1,
  };
  // repeated .ez_proto.Expr args = 2;
  int args_size() const;
  private:
  int _internal_args_size() const;

  public:
  void clear_args() ;
  ::ez_proto::Expr* mutable_args(int index);
  ::google::protobuf::RepeatedPtrField<::ez_proto::Expr>* mutable_args();

  private:
  const ::google::protobuf::RepeatedPtrField<::ez_proto::Expr>& _internal_args() const;
  ::google::protobuf::RepeatedPtrField<::ez_proto::Expr>* _internal_mutable_args();
  public:
  const ::ez_proto::Expr& args(int index) const;
  ::ez_proto::Expr* add_args();
  const ::google::protobuf::RepeatedPtrField<::ez_proto::Expr>& args() const;
  // required string callee = 1;
  bool has_callee() const;
  void clear_callee() ;
  const std::string& callee() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_callee(Arg_&& arg, Args_... args);
  std::string* mutable_callee();
  PROTOBUF_NODISCARD std::string* release_callee();
  void set_allocated_callee(std::string* value);

  private:
  const std::string& _internal_callee() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_callee(
      const std::string& value);
  std::string* _internal_mutable_callee();

  public:
  // @@protoc_insertion_point(class_scope:ez_proto.Expr.Call)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      33, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Expr_Call_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expr_Call& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::ez_proto::Expr > args_;
    ::google::protobuf::internal::ArenaStringPtr callee_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ez_5fir_2eproto;
};
// -------------------------------------------------------------------

class Statement_Declaration final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ez_proto.Statement.Declaration) */ {
 public:
  inline Statement_Declaration() : Statement_Declaration(nullptr) {}
  ~Statement_Declaration() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Statement_Declaration(
      ::google::protobuf::internal::ConstantInitialized);

  inline Statement_Declaration(const Statement_Declaration& from) : Statement_Declaration(nullptr, from) {}
  inline Statement_Declaration(Statement_Declaration&& from) noexcept
      : Statement_Declaration(nullptr, std::move(from)) {}
  inline Statement_Declaration& operator=(const Statement_Declaration& from) {
    CopyFrom(from);
    return *this;
  }
  inline Statement_Declaration& operator=(Statement_Declaration&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Statement_Declaration& default_instance() {
    return *internal_default_instance();
  }
  static inline const Statement_Declaration* internal_default_instance() {
    return reinterpret_cast<const Statement_Declaration*>(
        &_Statement_Declaration_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(Statement_Declaration& a, Statement_Declaration& b) { a.Swap(&b); }
  inline void Swap(Statement_Declaration* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Statement_Declaration* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Statement_Declaration* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Statement_Declaration>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Statement_Declaration& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Statement_Declaration& from) { Statement_Declaration::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Statement_Declaration* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ez_proto.Statement.Declaration"; }

 protected:
  explicit Statement_Declaration(::google::protobuf::Arena* arena);
  Statement_Declaration(::google::protobuf::Arena* arena, const Statement_Declaration& from);
  Statement_Declaration(::google::protobuf::Arena* arena, Statement_Declaration&& from) noexcept
      : Statement_Declaration(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kTypeFieldNumber = 2,
    kRhsFieldNumber = 3,
  };
  // required string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // required .ez_proto.EzType type = 2;
  bool has_type() const;
  void clear_type() ;
  const ::ez_proto::EzType& type() const;
  PROTOBUF_NODISCARD ::ez_proto::EzType* release_type();
  ::ez_proto::EzType* mutable_type();
  void set_allocated_type(::ez_proto::EzType* value);
  void unsafe_arena_set_allocated_type(::ez_proto::EzType* value);
  ::ez_proto::EzType* unsafe_arena_release_type();

  private:
  const ::ez_proto::EzType& _internal_type() const;
  ::ez_proto::EzType* _internal_mutable_type();

  public:
  // required .ez_proto.Expr rhs = 3;
  bool has_rhs() const;
  void clear_rhs() ;
  const ::ez_proto::Expr& rhs() const;
  PROTOBUF_NODISCARD ::ez_proto::Expr* release_rhs();
  ::ez_proto::Expr* mutable_rhs();
  void set_allocated_rhs(::ez_proto::Expr* value);
  void unsafe_arena_set_allocated_rhs(::ez_proto::Expr* value);
  ::ez_proto::Expr* unsafe_arena_release_rhs();

  private:
  const ::ez_proto::Expr& _internal_rhs() const;
  ::ez_proto::Expr* _internal_mutable_rhs();

  public:
  // @@protoc_insertion_point(class_scope:ez_proto.Statement.Declaration)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      43, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Statement_Declaration_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Statement_Declaration& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::ez_proto::EzType* type_;
    ::ez_proto::Expr* rhs_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ez_5fir_2eproto;
};
// -------------------------------------------------------------------

class Statement_Assign final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ez_proto.Statement.Assign) */ {
 public:
  inline Statement_Assign() : Statement_Assign(nullptr) {}
  ~Statement_Assign() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Statement_Assign(
      ::google::protobuf::internal::ConstantInitialized);

  inline Statement_Assign(const Statement_Assign& from) : Statement_Assign(nullptr, from) {}
  inline Statement_Assign(Statement_Assign&& from) noexcept
      : Statement_Assign(nullptr, std::move(from)) {}
  inline Statement_Assign& operator=(const Statement_Assign& from) {
    CopyFrom(from);
    return *this;
  }
  inline Statement_Assign& operator=(Statement_Assign&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Statement_Assign& default_instance() {
    return *internal_default_instance();
  }
  static inline const Statement_Assign* internal_default_instance() {
    return reinterpret_cast<const Statement_Assign*>(
        &_Statement_Assign_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(Statement_Assign& a, Statement_Assign& b) { a.Swap(&b); }
  inline void Swap(Statement_Assign* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Statement_Assign* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Statement_Assign* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Statement_Assign>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Statement_Assign& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Statement_Assign& from) { Statement_Assign::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Statement_Assign* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ez_proto.Statement.Assign"; }

 protected:
  explicit Statement_Assign(::google::protobuf::Arena* arena);
  Statement_Assign(::google::protobuf::Arena* arena, const Statement_Assign& from);
  Statement_Assign(::google::protobuf::Arena* arena, Statement_Assign&& from) noexcept
      : Statement_Assign(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kRhsFieldNumber = 2,
  };
  // required string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // required .ez_proto.Expr rhs = 2;
  bool has_rhs() const;
  void clear_rhs() ;
  const ::ez_proto::Expr& rhs() const;
  PROTOBUF_NODISCARD ::ez_proto::Expr* release_rhs();
  ::ez_proto::Expr* mutable_rhs();
  void set_allocated_rhs(::ez_proto::Expr* value);
  void unsafe_arena_set_allocated_rhs(::ez_proto::Expr* value);
  ::ez_proto::Expr* unsafe_arena_release_rhs();

  private:
  const ::ez_proto::Expr& _internal_rhs() const;
  ::ez_proto::Expr* _internal_mutable_rhs();

  public:
  // @@protoc_insertion_point(class_scope:ez_proto.Statement.Assign)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      38, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Statement_Assign_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Statement_Assign& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::ez_proto::Expr* rhs_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ez_5fir_2eproto;
};
// -------------------------------------------------------------------

class Statement final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ez_proto.Statement) */ {
 public:
  inline Statement() : Statement(nullptr) {}
  ~Statement() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Statement(
      ::google::protobuf::internal::ConstantInitialized);

  inline Statement(const Statement& from) : Statement(nullptr, from) {}
  inline Statement(Statement&& from) noexcept
      : Statement(nullptr, std::move(from)) {}
  inline Statement& operator=(const Statement& from) {
    CopyFrom(from);
    return *this;
  }
  inline Statement& operator=(Statement&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Statement& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kExpr = 1,
    kDeclaration = 2,
    kIf = 3,
    kBlock = 4,
    kWhile = 5,
    kReturn = 6,
    kAssign = 7,
    KIND_NOT_SET = 0,
  };
  static inline const Statement* internal_default_instance() {
    return reinterpret_cast<const Statement*>(
        &_Statement_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(Statement& a, Statement& b) { a.Swap(&b); }
  inline void Swap(Statement* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Statement* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Statement* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Statement>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Statement& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Statement& from) { Statement::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Statement* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ez_proto.Statement"; }

 protected:
  explicit Statement(::google::protobuf::Arena* arena);
  Statement(::google::protobuf::Arena* arena, const Statement& from);
  Statement(::google::protobuf::Arena* arena, Statement&& from) noexcept
      : Statement(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Declaration = Statement_Declaration;
  using If = Statement_If;
  using Block = Statement_Block;
  using While = Statement_While;
  using Assign = Statement_Assign;

  // accessors -------------------------------------------------------
  enum : int {
    kExprFieldNumber = 1,
    kDeclarationFieldNumber = 2,
    kIfFieldNumber = 3,
    kBlockFieldNumber = 4,
    kWhileFieldNumber = 5,
    kReturnFieldNumber = 6,
    kAssignFieldNumber = 7,
  };
  // .ez_proto.Expr expr = 1;
  bool has_expr() const;
  private:
  bool _internal_has_expr() const;

  public:
  void clear_expr() ;
  const ::ez_proto::Expr& expr() const;
  PROTOBUF_NODISCARD ::ez_proto::Expr* release_expr();
  ::ez_proto::Expr* mutable_expr();
  void set_allocated_expr(::ez_proto::Expr* value);
  void unsafe_arena_set_allocated_expr(::ez_proto::Expr* value);
  ::ez_proto::Expr* unsafe_arena_release_expr();

  private:
  const ::ez_proto::Expr& _internal_expr() const;
  ::ez_proto::Expr* _internal_mutable_expr();

  public:
  // .ez_proto.Statement.Declaration declaration = 2;
  bool has_declaration() const;
  private:
  bool _internal_has_declaration() const;

  public:
  void clear_declaration() ;
  const ::ez_proto::Statement_Declaration& declaration() const;
  PROTOBUF_NODISCARD ::ez_proto::Statement_Declaration* release_declaration();
  ::ez_proto::Statement_Declaration* mutable_declaration();
  void set_allocated_declaration(::ez_proto::Statement_Declaration* value);
  void unsafe_arena_set_allocated_declaration(::ez_proto::Statement_Declaration* value);
  ::ez_proto::Statement_Declaration* unsafe_arena_release_declaration();

  private:
  const ::ez_proto::Statement_Declaration& _internal_declaration() const;
  ::ez_proto::Statement_Declaration* _internal_mutable_declaration();

  public:
  // .ez_proto.Statement.If if = 3;
  bool has_if_() const;
  private:
  bool _internal_has_if_() const;

  public:
  void clear_if_() ;
  const ::ez_proto::Statement_If& if_() const;
  PROTOBUF_NODISCARD ::ez_proto::Statement_If* release_if_();
  ::ez_proto::Statement_If* mutable_if_();
  void set_allocated_if_(::ez_proto::Statement_If* value);
  void unsafe_arena_set_allocated_if_(::ez_proto::Statement_If* value);
  ::ez_proto::Statement_If* unsafe_arena_release_if_();

  private:
  const ::ez_proto::Statement_If& _internal_if_() const;
  ::ez_proto::Statement_If* _internal_mutable_if_();

  public:
  // .ez_proto.Statement.Block block = 4;
  bool has_block() const;
  private:
  bool _internal_has_block() const;

  public:
  void clear_block() ;
  const ::ez_proto::Statement_Block& block() const;
  PROTOBUF_NODISCARD ::ez_proto::Statement_Block* release_block();
  ::ez_proto::Statement_Block* mutable_block();
  void set_allocated_block(::ez_proto::Statement_Block* value);
  void unsafe_arena_set_allocated_block(::ez_proto::Statement_Block* value);
  ::ez_proto::Statement_Block* unsafe_arena_release_block();

  private:
  const ::ez_proto::Statement_Block& _internal_block() const;
  ::ez_proto::Statement_Block* _internal_mutable_block();

  public:
  // .ez_proto.Statement.While while = 5;
  bool has_while_() const;
  private:
  bool _internal_has_while_() const;

  public:
  void clear_while_() ;
  const ::ez_proto::Statement_While& while_() const;
  PROTOBUF_NODISCARD ::ez_proto::Statement_While* release_while_();
  ::ez_proto::Statement_While* mutable_while_();
  void set_allocated_while_(::ez_proto::Statement_While* value);
  void unsafe_arena_set_allocated_while_(::ez_proto::Statement_While* value);
  ::ez_proto::Statement_While* unsafe_arena_release_while_();

  private:
  const ::ez_proto::Statement_While& _internal_while_() const;
  ::ez_proto::Statement_While* _internal_mutable_while_();

  public:
  // .ez_proto.Expr return = 6;
  bool has_return_() const;
  private:
  bool _internal_has_return_() const;

  public:
  void clear_return_() ;
  const ::ez_proto::Expr& return_() const;
  PROTOBUF_NODISCARD ::ez_proto::Expr* release_return_();
  ::ez_proto::Expr* mutable_return_();
  void set_allocated_return_(::ez_proto::Expr* value);
  void unsafe_arena_set_allocated_return_(::ez_proto::Expr* value);
  ::ez_proto::Expr* unsafe_arena_release_return_();

  private:
  const ::ez_proto::Expr& _internal_return_() const;
  ::ez_proto::Expr* _internal_mutable_return_();

  public:
  // .ez_proto.Statement.Assign assign = 7;
  bool has_assign() const;
  private:
  bool _internal_has_assign() const;

  public:
  void clear_assign() ;
  const ::ez_proto::Statement_Assign& assign() const;
  PROTOBUF_NODISCARD ::ez_proto::Statement_Assign* release_assign();
  ::ez_proto::Statement_Assign* mutable_assign();
  void set_allocated_assign(::ez_proto::Statement_Assign* value);
  void unsafe_arena_set_allocated_assign(::ez_proto::Statement_Assign* value);
  ::ez_proto::Statement_Assign* unsafe_arena_release_assign();

  private:
  const ::ez_proto::Statement_Assign& _internal_assign() const;
  ::ez_proto::Statement_Assign* _internal_mutable_assign();

  public:
  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:ez_proto.Statement)
 private:
  class _Internal;
  void set_has_expr();
  void set_has_declaration();
  void set_has_if_();
  void set_has_block();
  void set_has_while_();
  void set_has_return_();
  void set_has_assign();
  inline bool has_kind() const;
  inline void clear_has_kind();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 7, 7,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Statement_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Statement& from_msg);
    union KindUnion {
      constexpr KindUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::ez_proto::Expr* expr_;
      ::ez_proto::Statement_Declaration* declaration_;
      ::ez_proto::Statement_If* if__;
      ::ez_proto::Statement_Block* block_;
      ::ez_proto::Statement_While* while__;
      ::ez_proto::Expr* return__;
      ::ez_proto::Statement_Assign* assign_;
    } kind_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ez_5fir_2eproto;
};
// -------------------------------------------------------------------

class Statement_Block final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ez_proto.Statement.Block) */ {
 public:
  inline Statement_Block() : Statement_Block(nullptr) {}
  ~Statement_Block() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Statement_Block(
      ::google::protobuf::internal::ConstantInitialized);

  inline Statement_Block(const Statement_Block& from) : Statement_Block(nullptr, from) {}
  inline Statement_Block(Statement_Block&& from) noexcept
      : Statement_Block(nullptr, std::move(from)) {}
  inline Statement_Block& operator=(const Statement_Block& from) {
    CopyFrom(from);
    return *this;
  }
  inline Statement_Block& operator=(Statement_Block&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Statement_Block& default_instance() {
    return *internal_default_instance();
  }
  static inline const Statement_Block* internal_default_instance() {
    return reinterpret_cast<const Statement_Block*>(
        &_Statement_Block_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(Statement_Block& a, Statement_Block& b) { a.Swap(&b); }
  inline void Swap(Statement_Block* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Statement_Block* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Statement_Block* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Statement_Block>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Statement_Block& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Statement_Block& from) { Statement_Block::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Statement_Block* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ez_proto.Statement.Block"; }

 protected:
  explicit Statement_Block(::google::protobuf::Arena* arena);
  Statement_Block(::google::protobuf::Arena* arena, const Statement_Block& from);
  Statement_Block(::google::protobuf::Arena* arena, Statement_Block&& from) noexcept
      : Statement_Block(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStatementsFieldNumber = 1,
  };
  // repeated .ez_proto.Statement statements = 1;
  int statements_size() const;
  private:
  int _internal_statements_size() const;

  public:
  void clear_statements() ;
  ::ez_proto::Statement* mutable_statements(int index);
  ::google::protobuf::RepeatedPtrField<::ez_proto::Statement>* mutable_statements();

  private:
  const ::google::protobuf::RepeatedPtrField<::ez_proto::Statement>& _internal_statements() const;
  ::google::protobuf::RepeatedPtrField<::ez_proto::Statement>* _internal_mutable_statements();
  public:
  const ::ez_proto::Statement& statements(int index) const;
  ::ez_proto::Statement* add_statements();
  const ::google::protobuf::RepeatedPtrField<::ez_proto::Statement>& statements() const;
  // @@protoc_insertion_point(class_scope:ez_proto.Statement.Block)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Statement_Block_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Statement_Block& from_msg);
    ::google::protobuf::RepeatedPtrField< ::ez_proto::Statement > statements_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ez_5fir_2eproto;
};
// -------------------------------------------------------------------

class Statement_If final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ez_proto.Statement.If) */ {
 public:
  inline Statement_If() : Statement_If(nullptr) {}
  ~Statement_If() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Statement_If(
      ::google::protobuf::internal::ConstantInitialized);

  inline Statement_If(const Statement_If& from) : Statement_If(nullptr, from) {}
  inline Statement_If(Statement_If&& from) noexcept
      : Statement_If(nullptr, std::move(from)) {}
  inline Statement_If& operator=(const Statement_If& from) {
    CopyFrom(from);
    return *this;
  }
  inline Statement_If& operator=(Statement_If&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Statement_If& default_instance() {
    return *internal_default_instance();
  }
  static inline const Statement_If* internal_default_instance() {
    return reinterpret_cast<const Statement_If*>(
        &_Statement_If_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(Statement_If& a, Statement_If& b) { a.Swap(&b); }
  inline void Swap(Statement_If* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Statement_If* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Statement_If* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Statement_If>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Statement_If& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Statement_If& from) { Statement_If::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Statement_If* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ez_proto.Statement.If"; }

 protected:
  explicit Statement_If(::google::protobuf::Arena* arena);
  Statement_If(::google::protobuf::Arena* arena, const Statement_If& from);
  Statement_If(::google::protobuf::Arena* arena, Statement_If&& from) noexcept
      : Statement_If(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kConditionFieldNumber = 1,
    kThenBranchFieldNumber = 2,
    kElseBranchFieldNumber = 3,
  };
  // required .ez_proto.Expr condition = 1;
  bool has_condition() const;
  void clear_condition() ;
  const ::ez_proto::Expr& condition() const;
  PROTOBUF_NODISCARD ::ez_proto::Expr* release_condition();
  ::ez_proto::Expr* mutable_condition();
  void set_allocated_condition(::ez_proto::Expr* value);
  void unsafe_arena_set_allocated_condition(::ez_proto::Expr* value);
  ::ez_proto::Expr* unsafe_arena_release_condition();

  private:
  const ::ez_proto::Expr& _internal_condition() const;
  ::ez_proto::Expr* _internal_mutable_condition();

  public:
  // required .ez_proto.Statement then_branch = 2;
  bool has_then_branch() const;
  void clear_then_branch() ;
  const ::ez_proto::Statement& then_branch() const;
  PROTOBUF_NODISCARD ::ez_proto::Statement* release_then_branch();
  ::ez_proto::Statement* mutable_then_branch();
  void set_allocated_then_branch(::ez_proto::Statement* value);
  void unsafe_arena_set_allocated_then_branch(::ez_proto::Statement* value);
  ::ez_proto::Statement* unsafe_arena_release_then_branch();

  private:
  const ::ez_proto::Statement& _internal_then_branch() const;
  ::ez_proto::Statement* _internal_mutable_then_branch();

  public:
  // required .ez_proto.Statement else_branch = 3;
  bool has_else_branch() const;
  void clear_else_branch() ;
  const ::ez_proto::Statement& else_branch() const;
  PROTOBUF_NODISCARD ::ez_proto::Statement* release_else_branch();
  ::ez_proto::Statement* mutable_else_branch();
  void set_allocated_else_branch(::ez_proto::Statement* value);
  void unsafe_arena_set_allocated_else_branch(::ez_proto::Statement* value);
  ::ez_proto::Statement* unsafe_arena_release_else_branch();

  private:
  const ::ez_proto::Statement& _internal_else_branch() const;
  ::ez_proto::Statement* _internal_mutable_else_branch();

  public:
  // @@protoc_insertion_point(class_scope:ez_proto.Statement.If)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Statement_If_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Statement_If& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::ez_proto::Expr* condition_;
    ::ez_proto::Statement* then_branch_;
    ::ez_proto::Statement* else_branch_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ez_5fir_2eproto;
};
// -------------------------------------------------------------------

class Statement_While final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ez_proto.Statement.While) */ {
 public:
  inline Statement_While() : Statement_While(nullptr) {}
  ~Statement_While() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Statement_While(
      ::google::protobuf::internal::ConstantInitialized);

  inline Statement_While(const Statement_While& from) : Statement_While(nullptr, from) {}
  inline Statement_While(Statement_While&& from) noexcept
      : Statement_While(nullptr, std::move(from)) {}
  inline Statement_While& operator=(const Statement_While& from) {
    CopyFrom(from);
    return *this;
  }
  inline Statement_While& operator=(Statement_While&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Statement_While& default_instance() {
    return *internal_default_instance();
  }
  static inline const Statement_While* internal_default_instance() {
    return reinterpret_cast<const Statement_While*>(
        &_Statement_While_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(Statement_While& a, Statement_While& b) { a.Swap(&b); }
  inline void Swap(Statement_While* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Statement_While* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Statement_While* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Statement_While>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Statement_While& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Statement_While& from) { Statement_While::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Statement_While* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ez_proto.Statement.While"; }

 protected:
  explicit Statement_While(::google::protobuf::Arena* arena);
  Statement_While(::google::protobuf::Arena* arena, const Statement_While& from);
  Statement_While(::google::protobuf::Arena* arena, Statement_While&& from) noexcept
      : Statement_While(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kConditionFieldNumber = 1,
    kBodyFieldNumber = 2,
  };
  // required .ez_proto.Expr condition = 1;
  bool has_condition() const;
  void clear_condition() ;
  const ::ez_proto::Expr& condition() const;
  PROTOBUF_NODISCARD ::ez_proto::Expr* release_condition();
  ::ez_proto::Expr* mutable_condition();
  void set_allocated_condition(::ez_proto::Expr* value);
  void unsafe_arena_set_allocated_condition(::ez_proto::Expr* value);
  ::ez_proto::Expr* unsafe_arena_release_condition();

  private:
  const ::ez_proto::Expr& _internal_condition() const;
  ::ez_proto::Expr* _internal_mutable_condition();

  public:
  // required .ez_proto.Statement body = 2;
  bool has_body() const;
  void clear_body() ;
  const ::ez_proto::Statement& body() const;
  PROTOBUF_NODISCARD ::ez_proto::Statement* release_body();
  ::ez_proto::Statement* mutable_body();
  void set_allocated_body(::ez_proto::Statement* value);
  void unsafe_arena_set_allocated_body(::ez_proto::Statement* value);
  ::ez_proto::Statement* unsafe_arena_release_body();

  private:
  const ::ez_proto::Statement& _internal_body() const;
  ::ez_proto::Statement* _internal_mutable_body();

  public:
  // @@protoc_insertion_point(class_scope:ez_proto.Statement.While)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Statement_While_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Statement_While& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::ez_proto::Expr* condition_;
    ::ez_proto::Statement* body_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ez_5fir_2eproto;
};
// -------------------------------------------------------------------

class Definition final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ez_proto.Definition) */ {
 public:
  inline Definition() : Definition(nullptr) {}
  ~Definition() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Definition(
      ::google::protobuf::internal::ConstantInitialized);

  inline Definition(const Definition& from) : Definition(nullptr, from) {}
  inline Definition(Definition&& from) noexcept
      : Definition(nullptr, std::move(from)) {}
  inline Definition& operator=(const Definition& from) {
    CopyFrom(from);
    return *this;
  }
  inline Definition& operator=(Definition&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Definition& default_instance() {
    return *internal_default_instance();
  }
  static inline const Definition* internal_default_instance() {
    return reinterpret_cast<const Definition*>(
        &_Definition_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(Definition& a, Definition& b) { a.Swap(&b); }
  inline void Swap(Definition* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Definition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Definition* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Definition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Definition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Definition& from) { Definition::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Definition* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ez_proto.Definition"; }

 protected:
  explicit Definition(::google::protobuf::Arena* arena);
  Definition(::google::protobuf::Arena* arena, const Definition& from);
  Definition(::google::protobuf::Arena* arena, Definition&& from) noexcept
      : Definition(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using EzTypedParam = Definition_EzTypedParam;

  // accessors -------------------------------------------------------
  enum : int {
    kParamsFieldNumber = 3,
    kNameFieldNumber = 2,
    kReturnTypeFieldNumber = 1,
    kBodyFieldNumber = 4,
  };
  // repeated .ez_proto.Definition.EzTypedParam params = 3;
  int params_size() const;
  private:
  int _internal_params_size() const;

  public:
  void clear_params() ;
  ::ez_proto::Definition_EzTypedParam* mutable_params(int index);
  ::google::protobuf::RepeatedPtrField<::ez_proto::Definition_EzTypedParam>* mutable_params();

  private:
  const ::google::protobuf::RepeatedPtrField<::ez_proto::Definition_EzTypedParam>& _internal_params() const;
  ::google::protobuf::RepeatedPtrField<::ez_proto::Definition_EzTypedParam>* _internal_mutable_params();
  public:
  const ::ez_proto::Definition_EzTypedParam& params(int index) const;
  ::ez_proto::Definition_EzTypedParam* add_params();
  const ::google::protobuf::RepeatedPtrField<::ez_proto::Definition_EzTypedParam>& params() const;
  // required string name = 2;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // required .ez_proto.EzType return_type = 1;
  bool has_return_type() const;
  void clear_return_type() ;
  const ::ez_proto::EzType& return_type() const;
  PROTOBUF_NODISCARD ::ez_proto::EzType* release_return_type();
  ::ez_proto::EzType* mutable_return_type();
  void set_allocated_return_type(::ez_proto::EzType* value);
  void unsafe_arena_set_allocated_return_type(::ez_proto::EzType* value);
  ::ez_proto::EzType* unsafe_arena_release_return_type();

  private:
  const ::ez_proto::EzType& _internal_return_type() const;
  ::ez_proto::EzType* _internal_mutable_return_type();

  public:
  // required .ez_proto.Statement body = 4;
  bool has_body() const;
  void clear_body() ;
  const ::ez_proto::Statement& body() const;
  PROTOBUF_NODISCARD ::ez_proto::Statement* release_body();
  ::ez_proto::Statement* mutable_body();
  void set_allocated_body(::ez_proto::Statement* value);
  void unsafe_arena_set_allocated_body(::ez_proto::Statement* value);
  ::ez_proto::Statement* unsafe_arena_release_body();

  private:
  const ::ez_proto::Statement& _internal_body() const;
  ::ez_proto::Statement* _internal_mutable_body();

  public:
  // @@protoc_insertion_point(class_scope:ez_proto.Definition)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 3,
      32, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Definition_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Definition& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::ez_proto::Definition_EzTypedParam > params_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::ez_proto::EzType* return_type_;
    ::ez_proto::Statement* body_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ez_5fir_2eproto;
};
// -------------------------------------------------------------------

class Program final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ez_proto.Program) */ {
 public:
  inline Program() : Program(nullptr) {}
  ~Program() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Program(
      ::google::protobuf::internal::ConstantInitialized);

  inline Program(const Program& from) : Program(nullptr, from) {}
  inline Program(Program&& from) noexcept
      : Program(nullptr, std::move(from)) {}
  inline Program& operator=(const Program& from) {
    CopyFrom(from);
    return *this;
  }
  inline Program& operator=(Program&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Program& default_instance() {
    return *internal_default_instance();
  }
  static inline const Program* internal_default_instance() {
    return reinterpret_cast<const Program*>(
        &_Program_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(Program& a, Program& b) { a.Swap(&b); }
  inline void Swap(Program* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Program* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Program* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Program>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Program& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Program& from) { Program::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Program* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ez_proto.Program"; }

 protected:
  explicit Program(::google::protobuf::Arena* arena);
  Program(::google::protobuf::Arena* arena, const Program& from);
  Program(::google::protobuf::Arena* arena, Program&& from) noexcept
      : Program(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDefinitionsFieldNumber = 1,
  };
  // repeated .ez_proto.Definition definitions = 1;
  int definitions_size() const;
  private:
  int _internal_definitions_size() const;

  public:
  void clear_definitions() ;
  ::ez_proto::Definition* mutable_definitions(int index);
  ::google::protobuf::RepeatedPtrField<::ez_proto::Definition>* mutable_definitions();

  private:
  const ::google::protobuf::RepeatedPtrField<::ez_proto::Definition>& _internal_definitions() const;
  ::google::protobuf::RepeatedPtrField<::ez_proto::Definition>* _internal_mutable_definitions();
  public:
  const ::ez_proto::Definition& definitions(int index) const;
  ::ez_proto::Definition* add_definitions();
  const ::google::protobuf::RepeatedPtrField<::ez_proto::Definition>& definitions() const;
  // @@protoc_insertion_point(class_scope:ez_proto.Program)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Program_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Program& from_msg);
    ::google::protobuf::RepeatedPtrField< ::ez_proto::Definition > definitions_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ez_5fir_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// EzType

// .ez_proto.EzType.NonPtr non_ptr = 1;
inline bool EzType::has_non_ptr() const {
  return kind_case() == kNonPtr;
}
inline void EzType::set_has_non_ptr() {
  _impl_._oneof_case_[0] = kNonPtr;
}
inline void EzType::clear_non_ptr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kNonPtr) {
    _impl_.kind_.non_ptr_ = 0;
    clear_has_kind();
  }
}
inline ::ez_proto::EzType_NonPtr EzType::non_ptr() const {
  // @@protoc_insertion_point(field_get:ez_proto.EzType.non_ptr)
  return _internal_non_ptr();
}
inline void EzType::set_non_ptr(::ez_proto::EzType_NonPtr value) {
  assert(::ez_proto::EzType_NonPtr_IsValid(value));
  if (kind_case() != kNonPtr) {
    clear_kind();
    set_has_non_ptr();
  }
  _impl_.kind_.non_ptr_ = value;
  // @@protoc_insertion_point(field_set:ez_proto.EzType.non_ptr)
}
inline ::ez_proto::EzType_NonPtr EzType::_internal_non_ptr() const {
  if (kind_case() == kNonPtr) {
    return static_cast<::ez_proto::EzType_NonPtr>(_impl_.kind_.non_ptr_);
  }
  return static_cast<::ez_proto::EzType_NonPtr>(0);
}

// .ez_proto.EzType ptr = 2;
inline bool EzType::has_ptr() const {
  return kind_case() == kPtr;
}
inline bool EzType::_internal_has_ptr() const {
  return kind_case() == kPtr;
}
inline void EzType::set_has_ptr() {
  _impl_._oneof_case_[0] = kPtr;
}
inline void EzType::clear_ptr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kPtr) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.ptr_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.ptr_);
    }
    clear_has_kind();
  }
}
inline ::ez_proto::EzType* EzType::release_ptr() {
  // @@protoc_insertion_point(field_release:ez_proto.EzType.ptr)
  if (kind_case() == kPtr) {
    clear_has_kind();
    auto* temp = _impl_.kind_.ptr_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.ptr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ez_proto::EzType& EzType::_internal_ptr() const {
  return kind_case() == kPtr ? *_impl_.kind_.ptr_ : reinterpret_cast<::ez_proto::EzType&>(::ez_proto::_EzType_default_instance_);
}
inline const ::ez_proto::EzType& EzType::ptr() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.EzType.ptr)
  return _internal_ptr();
}
inline ::ez_proto::EzType* EzType::unsafe_arena_release_ptr() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ez_proto.EzType.ptr)
  if (kind_case() == kPtr) {
    clear_has_kind();
    auto* temp = _impl_.kind_.ptr_;
    _impl_.kind_.ptr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EzType::unsafe_arena_set_allocated_ptr(::ez_proto::EzType* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_ptr();
    _impl_.kind_.ptr_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ez_proto.EzType.ptr)
}
inline ::ez_proto::EzType* EzType::_internal_mutable_ptr() {
  if (kind_case() != kPtr) {
    clear_kind();
    set_has_ptr();
    _impl_.kind_.ptr_ =
        ::google::protobuf::Message::DefaultConstruct<::ez_proto::EzType>(GetArena());
  }
  return _impl_.kind_.ptr_;
}
inline ::ez_proto::EzType* EzType::mutable_ptr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ez_proto::EzType* _msg = _internal_mutable_ptr();
  // @@protoc_insertion_point(field_mutable:ez_proto.EzType.ptr)
  return _msg;
}

inline bool EzType::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void EzType::clear_has_kind() {
  _impl_._oneof_case_[0] = KIND_NOT_SET;
}
inline EzType::KindCase EzType::kind_case() const {
  return EzType::KindCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Value_Unit

// -------------------------------------------------------------------

// Value

// .ez_proto.Value.Unit unit_val = 1;
inline bool Value::has_unit_val() const {
  return kind_case() == kUnitVal;
}
inline bool Value::_internal_has_unit_val() const {
  return kind_case() == kUnitVal;
}
inline void Value::set_has_unit_val() {
  _impl_._oneof_case_[0] = kUnitVal;
}
inline void Value::clear_unit_val() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kUnitVal) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.unit_val_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.unit_val_);
    }
    clear_has_kind();
  }
}
inline ::ez_proto::Value_Unit* Value::release_unit_val() {
  // @@protoc_insertion_point(field_release:ez_proto.Value.unit_val)
  if (kind_case() == kUnitVal) {
    clear_has_kind();
    auto* temp = _impl_.kind_.unit_val_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.unit_val_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ez_proto::Value_Unit& Value::_internal_unit_val() const {
  return kind_case() == kUnitVal ? *_impl_.kind_.unit_val_ : reinterpret_cast<::ez_proto::Value_Unit&>(::ez_proto::_Value_Unit_default_instance_);
}
inline const ::ez_proto::Value_Unit& Value::unit_val() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.Value.unit_val)
  return _internal_unit_val();
}
inline ::ez_proto::Value_Unit* Value::unsafe_arena_release_unit_val() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ez_proto.Value.unit_val)
  if (kind_case() == kUnitVal) {
    clear_has_kind();
    auto* temp = _impl_.kind_.unit_val_;
    _impl_.kind_.unit_val_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_unit_val(::ez_proto::Value_Unit* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_unit_val();
    _impl_.kind_.unit_val_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ez_proto.Value.unit_val)
}
inline ::ez_proto::Value_Unit* Value::_internal_mutable_unit_val() {
  if (kind_case() != kUnitVal) {
    clear_kind();
    set_has_unit_val();
    _impl_.kind_.unit_val_ =
        ::google::protobuf::Message::DefaultConstruct<::ez_proto::Value_Unit>(GetArena());
  }
  return _impl_.kind_.unit_val_;
}
inline ::ez_proto::Value_Unit* Value::mutable_unit_val() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ez_proto::Value_Unit* _msg = _internal_mutable_unit_val();
  // @@protoc_insertion_point(field_mutable:ez_proto.Value.unit_val)
  return _msg;
}

// int64 i64_val = 2;
inline bool Value::has_i64_val() const {
  return kind_case() == kI64Val;
}
inline void Value::set_has_i64_val() {
  _impl_._oneof_case_[0] = kI64Val;
}
inline void Value::clear_i64_val() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kI64Val) {
    _impl_.kind_.i64_val_ = ::int64_t{0};
    clear_has_kind();
  }
}
inline ::int64_t Value::i64_val() const {
  // @@protoc_insertion_point(field_get:ez_proto.Value.i64_val)
  return _internal_i64_val();
}
inline void Value::set_i64_val(::int64_t value) {
  if (kind_case() != kI64Val) {
    clear_kind();
    set_has_i64_val();
  }
  _impl_.kind_.i64_val_ = value;
  // @@protoc_insertion_point(field_set:ez_proto.Value.i64_val)
}
inline ::int64_t Value::_internal_i64_val() const {
  if (kind_case() == kI64Val) {
    return _impl_.kind_.i64_val_;
  }
  return ::int64_t{0};
}

// string str_val = 3;
inline bool Value::has_str_val() const {
  return kind_case() == kStrVal;
}
inline void Value::set_has_str_val() {
  _impl_._oneof_case_[0] = kStrVal;
}
inline void Value::clear_str_val() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kStrVal) {
    _impl_.kind_.str_val_.Destroy();
    clear_has_kind();
  }
}
inline const std::string& Value::str_val() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.Value.str_val)
  return _internal_str_val();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Value::set_str_val(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() != kStrVal) {
    clear_kind();

    set_has_str_val();
    _impl_.kind_.str_val_.InitDefault();
  }
  _impl_.kind_.str_val_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ez_proto.Value.str_val)
}
inline std::string* Value::mutable_str_val() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_str_val();
  // @@protoc_insertion_point(field_mutable:ez_proto.Value.str_val)
  return _s;
}
inline const std::string& Value::_internal_str_val() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (kind_case() != kStrVal) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.kind_.str_val_.Get();
}
inline void Value::_internal_set_str_val(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() != kStrVal) {
    clear_kind();

    set_has_str_val();
    _impl_.kind_.str_val_.InitDefault();
  }
  _impl_.kind_.str_val_.Set(value, GetArena());
}
inline std::string* Value::_internal_mutable_str_val() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() != kStrVal) {
    clear_kind();

    set_has_str_val();
    _impl_.kind_.str_val_.InitDefault();
  }
  return _impl_.kind_.str_val_.Mutable( GetArena());
}
inline std::string* Value::release_str_val() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ez_proto.Value.str_val)
  if (kind_case() != kStrVal) {
    return nullptr;
  }
  clear_has_kind();
  return _impl_.kind_.str_val_.Release();
}
inline void Value::set_allocated_str_val(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_kind()) {
    clear_kind();
  }
  if (value != nullptr) {
    set_has_str_val();
    _impl_.kind_.str_val_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ez_proto.Value.str_val)
}

// double f64_val = 4;
inline bool Value::has_f64_val() const {
  return kind_case() == kF64Val;
}
inline void Value::set_has_f64_val() {
  _impl_._oneof_case_[0] = kF64Val;
}
inline void Value::clear_f64_val() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kF64Val) {
    _impl_.kind_.f64_val_ = 0;
    clear_has_kind();
  }
}
inline double Value::f64_val() const {
  // @@protoc_insertion_point(field_get:ez_proto.Value.f64_val)
  return _internal_f64_val();
}
inline void Value::set_f64_val(double value) {
  if (kind_case() != kF64Val) {
    clear_kind();
    set_has_f64_val();
  }
  _impl_.kind_.f64_val_ = value;
  // @@protoc_insertion_point(field_set:ez_proto.Value.f64_val)
}
inline double Value::_internal_f64_val() const {
  if (kind_case() == kF64Val) {
    return _impl_.kind_.f64_val_;
  }
  return 0;
}

// bool bool_val = 5;
inline bool Value::has_bool_val() const {
  return kind_case() == kBoolVal;
}
inline void Value::set_has_bool_val() {
  _impl_._oneof_case_[0] = kBoolVal;
}
inline void Value::clear_bool_val() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kBoolVal) {
    _impl_.kind_.bool_val_ = false;
    clear_has_kind();
  }
}
inline bool Value::bool_val() const {
  // @@protoc_insertion_point(field_get:ez_proto.Value.bool_val)
  return _internal_bool_val();
}
inline void Value::set_bool_val(bool value) {
  if (kind_case() != kBoolVal) {
    clear_kind();
    set_has_bool_val();
  }
  _impl_.kind_.bool_val_ = value;
  // @@protoc_insertion_point(field_set:ez_proto.Value.bool_val)
}
inline bool Value::_internal_bool_val() const {
  if (kind_case() == kBoolVal) {
    return _impl_.kind_.bool_val_;
  }
  return false;
}

inline bool Value::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void Value::clear_has_kind() {
  _impl_._oneof_case_[0] = KIND_NOT_SET;
}
inline Value::KindCase Value::kind_case() const {
  return Value::KindCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Expr_Binary

// required .ez_proto.Expr.Binary.BinOp op = 1;
inline bool Expr_Binary::has_op() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Expr_Binary::clear_op() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::ez_proto::Expr_Binary_BinOp Expr_Binary::op() const {
  // @@protoc_insertion_point(field_get:ez_proto.Expr.Binary.op)
  return _internal_op();
}
inline void Expr_Binary::set_op(::ez_proto::Expr_Binary_BinOp value) {
  _internal_set_op(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:ez_proto.Expr.Binary.op)
}
inline ::ez_proto::Expr_Binary_BinOp Expr_Binary::_internal_op() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::ez_proto::Expr_Binary_BinOp>(_impl_.op_);
}
inline void Expr_Binary::_internal_set_op(::ez_proto::Expr_Binary_BinOp value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::ez_proto::Expr_Binary_BinOp_IsValid(value));
  _impl_.op_ = value;
}

// required .ez_proto.Expr lhs = 2;
inline bool Expr_Binary::has_lhs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lhs_ != nullptr);
  return value;
}
inline void Expr_Binary::clear_lhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lhs_ != nullptr) _impl_.lhs_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ez_proto::Expr& Expr_Binary::_internal_lhs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::ez_proto::Expr* p = _impl_.lhs_;
  return p != nullptr ? *p : reinterpret_cast<const ::ez_proto::Expr&>(::ez_proto::_Expr_default_instance_);
}
inline const ::ez_proto::Expr& Expr_Binary::lhs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.Expr.Binary.lhs)
  return _internal_lhs();
}
inline void Expr_Binary::unsafe_arena_set_allocated_lhs(::ez_proto::Expr* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lhs_);
  }
  _impl_.lhs_ = reinterpret_cast<::ez_proto::Expr*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ez_proto.Expr.Binary.lhs)
}
inline ::ez_proto::Expr* Expr_Binary::release_lhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ez_proto::Expr* released = _impl_.lhs_;
  _impl_.lhs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ez_proto::Expr* Expr_Binary::unsafe_arena_release_lhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ez_proto.Expr.Binary.lhs)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ez_proto::Expr* temp = _impl_.lhs_;
  _impl_.lhs_ = nullptr;
  return temp;
}
inline ::ez_proto::Expr* Expr_Binary::_internal_mutable_lhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lhs_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::ez_proto::Expr>(GetArena());
    _impl_.lhs_ = reinterpret_cast<::ez_proto::Expr*>(p);
  }
  return _impl_.lhs_;
}
inline ::ez_proto::Expr* Expr_Binary::mutable_lhs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::ez_proto::Expr* _msg = _internal_mutable_lhs();
  // @@protoc_insertion_point(field_mutable:ez_proto.Expr.Binary.lhs)
  return _msg;
}
inline void Expr_Binary::set_allocated_lhs(::ez_proto::Expr* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.lhs_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.lhs_ = reinterpret_cast<::ez_proto::Expr*>(value);
  // @@protoc_insertion_point(field_set_allocated:ez_proto.Expr.Binary.lhs)
}

// required .ez_proto.Expr rhs = 3;
inline bool Expr_Binary::has_rhs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rhs_ != nullptr);
  return value;
}
inline void Expr_Binary::clear_rhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rhs_ != nullptr) _impl_.rhs_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ez_proto::Expr& Expr_Binary::_internal_rhs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::ez_proto::Expr* p = _impl_.rhs_;
  return p != nullptr ? *p : reinterpret_cast<const ::ez_proto::Expr&>(::ez_proto::_Expr_default_instance_);
}
inline const ::ez_proto::Expr& Expr_Binary::rhs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.Expr.Binary.rhs)
  return _internal_rhs();
}
inline void Expr_Binary::unsafe_arena_set_allocated_rhs(::ez_proto::Expr* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rhs_);
  }
  _impl_.rhs_ = reinterpret_cast<::ez_proto::Expr*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ez_proto.Expr.Binary.rhs)
}
inline ::ez_proto::Expr* Expr_Binary::release_rhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ez_proto::Expr* released = _impl_.rhs_;
  _impl_.rhs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ez_proto::Expr* Expr_Binary::unsafe_arena_release_rhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ez_proto.Expr.Binary.rhs)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ez_proto::Expr* temp = _impl_.rhs_;
  _impl_.rhs_ = nullptr;
  return temp;
}
inline ::ez_proto::Expr* Expr_Binary::_internal_mutable_rhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rhs_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::ez_proto::Expr>(GetArena());
    _impl_.rhs_ = reinterpret_cast<::ez_proto::Expr*>(p);
  }
  return _impl_.rhs_;
}
inline ::ez_proto::Expr* Expr_Binary::mutable_rhs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::ez_proto::Expr* _msg = _internal_mutable_rhs();
  // @@protoc_insertion_point(field_mutable:ez_proto.Expr.Binary.rhs)
  return _msg;
}
inline void Expr_Binary::set_allocated_rhs(::ez_proto::Expr* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.rhs_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.rhs_ = reinterpret_cast<::ez_proto::Expr*>(value);
  // @@protoc_insertion_point(field_set_allocated:ez_proto.Expr.Binary.rhs)
}

// -------------------------------------------------------------------

// Expr_Call

// required string callee = 1;
inline bool Expr_Call::has_callee() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Expr_Call::clear_callee() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.callee_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Expr_Call::callee() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.Expr.Call.callee)
  return _internal_callee();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Expr_Call::set_callee(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.callee_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ez_proto.Expr.Call.callee)
}
inline std::string* Expr_Call::mutable_callee() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_callee();
  // @@protoc_insertion_point(field_mutable:ez_proto.Expr.Call.callee)
  return _s;
}
inline const std::string& Expr_Call::_internal_callee() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.callee_.Get();
}
inline void Expr_Call::_internal_set_callee(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.callee_.Set(value, GetArena());
}
inline std::string* Expr_Call::_internal_mutable_callee() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.callee_.Mutable( GetArena());
}
inline std::string* Expr_Call::release_callee() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ez_proto.Expr.Call.callee)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.callee_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.callee_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Expr_Call::set_allocated_callee(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.callee_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.callee_.IsDefault()) {
          _impl_.callee_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ez_proto.Expr.Call.callee)
}

// repeated .ez_proto.Expr args = 2;
inline int Expr_Call::_internal_args_size() const {
  return _internal_args().size();
}
inline int Expr_Call::args_size() const {
  return _internal_args_size();
}
inline void Expr_Call::clear_args() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.args_.Clear();
}
inline ::ez_proto::Expr* Expr_Call::mutable_args(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ez_proto.Expr.Call.args)
  return _internal_mutable_args()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::ez_proto::Expr>* Expr_Call::mutable_args()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ez_proto.Expr.Call.args)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_args();
}
inline const ::ez_proto::Expr& Expr_Call::args(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.Expr.Call.args)
  return _internal_args().Get(index);
}
inline ::ez_proto::Expr* Expr_Call::add_args() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::ez_proto::Expr* _add = _internal_mutable_args()->Add();
  // @@protoc_insertion_point(field_add:ez_proto.Expr.Call.args)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::ez_proto::Expr>& Expr_Call::args() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ez_proto.Expr.Call.args)
  return _internal_args();
}
inline const ::google::protobuf::RepeatedPtrField<::ez_proto::Expr>&
Expr_Call::_internal_args() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.args_;
}
inline ::google::protobuf::RepeatedPtrField<::ez_proto::Expr>*
Expr_Call::_internal_mutable_args() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.args_;
}

// -------------------------------------------------------------------

// Expr

// .ez_proto.Expr.Binary binary = 1;
inline bool Expr::has_binary() const {
  return kind_case() == kBinary;
}
inline bool Expr::_internal_has_binary() const {
  return kind_case() == kBinary;
}
inline void Expr::set_has_binary() {
  _impl_._oneof_case_[0] = kBinary;
}
inline void Expr::clear_binary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kBinary) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.binary_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.binary_);
    }
    clear_has_kind();
  }
}
inline ::ez_proto::Expr_Binary* Expr::release_binary() {
  // @@protoc_insertion_point(field_release:ez_proto.Expr.binary)
  if (kind_case() == kBinary) {
    clear_has_kind();
    auto* temp = _impl_.kind_.binary_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.binary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ez_proto::Expr_Binary& Expr::_internal_binary() const {
  return kind_case() == kBinary ? *_impl_.kind_.binary_ : reinterpret_cast<::ez_proto::Expr_Binary&>(::ez_proto::_Expr_Binary_default_instance_);
}
inline const ::ez_proto::Expr_Binary& Expr::binary() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.Expr.binary)
  return _internal_binary();
}
inline ::ez_proto::Expr_Binary* Expr::unsafe_arena_release_binary() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ez_proto.Expr.binary)
  if (kind_case() == kBinary) {
    clear_has_kind();
    auto* temp = _impl_.kind_.binary_;
    _impl_.kind_.binary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expr::unsafe_arena_set_allocated_binary(::ez_proto::Expr_Binary* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_binary();
    _impl_.kind_.binary_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ez_proto.Expr.binary)
}
inline ::ez_proto::Expr_Binary* Expr::_internal_mutable_binary() {
  if (kind_case() != kBinary) {
    clear_kind();
    set_has_binary();
    _impl_.kind_.binary_ =
        ::google::protobuf::Message::DefaultConstruct<::ez_proto::Expr_Binary>(GetArena());
  }
  return _impl_.kind_.binary_;
}
inline ::ez_proto::Expr_Binary* Expr::mutable_binary() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ez_proto::Expr_Binary* _msg = _internal_mutable_binary();
  // @@protoc_insertion_point(field_mutable:ez_proto.Expr.binary)
  return _msg;
}

// .ez_proto.Value value = 2;
inline bool Expr::has_value() const {
  return kind_case() == kValue;
}
inline bool Expr::_internal_has_value() const {
  return kind_case() == kValue;
}
inline void Expr::set_has_value() {
  _impl_._oneof_case_[0] = kValue;
}
inline void Expr::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kValue) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.value_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.value_);
    }
    clear_has_kind();
  }
}
inline ::ez_proto::Value* Expr::release_value() {
  // @@protoc_insertion_point(field_release:ez_proto.Expr.value)
  if (kind_case() == kValue) {
    clear_has_kind();
    auto* temp = _impl_.kind_.value_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ez_proto::Value& Expr::_internal_value() const {
  return kind_case() == kValue ? *_impl_.kind_.value_ : reinterpret_cast<::ez_proto::Value&>(::ez_proto::_Value_default_instance_);
}
inline const ::ez_proto::Value& Expr::value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.Expr.value)
  return _internal_value();
}
inline ::ez_proto::Value* Expr::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ez_proto.Expr.value)
  if (kind_case() == kValue) {
    clear_has_kind();
    auto* temp = _impl_.kind_.value_;
    _impl_.kind_.value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expr::unsafe_arena_set_allocated_value(::ez_proto::Value* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_value();
    _impl_.kind_.value_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ez_proto.Expr.value)
}
inline ::ez_proto::Value* Expr::_internal_mutable_value() {
  if (kind_case() != kValue) {
    clear_kind();
    set_has_value();
    _impl_.kind_.value_ =
        ::google::protobuf::Message::DefaultConstruct<::ez_proto::Value>(GetArena());
  }
  return _impl_.kind_.value_;
}
inline ::ez_proto::Value* Expr::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ez_proto::Value* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:ez_proto.Expr.value)
  return _msg;
}

// string variable = 3;
inline bool Expr::has_variable() const {
  return kind_case() == kVariable;
}
inline void Expr::set_has_variable() {
  _impl_._oneof_case_[0] = kVariable;
}
inline void Expr::clear_variable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kVariable) {
    _impl_.kind_.variable_.Destroy();
    clear_has_kind();
  }
}
inline const std::string& Expr::variable() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.Expr.variable)
  return _internal_variable();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Expr::set_variable(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() != kVariable) {
    clear_kind();

    set_has_variable();
    _impl_.kind_.variable_.InitDefault();
  }
  _impl_.kind_.variable_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ez_proto.Expr.variable)
}
inline std::string* Expr::mutable_variable() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_variable();
  // @@protoc_insertion_point(field_mutable:ez_proto.Expr.variable)
  return _s;
}
inline const std::string& Expr::_internal_variable() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (kind_case() != kVariable) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.kind_.variable_.Get();
}
inline void Expr::_internal_set_variable(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() != kVariable) {
    clear_kind();

    set_has_variable();
    _impl_.kind_.variable_.InitDefault();
  }
  _impl_.kind_.variable_.Set(value, GetArena());
}
inline std::string* Expr::_internal_mutable_variable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() != kVariable) {
    clear_kind();

    set_has_variable();
    _impl_.kind_.variable_.InitDefault();
  }
  return _impl_.kind_.variable_.Mutable( GetArena());
}
inline std::string* Expr::release_variable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ez_proto.Expr.variable)
  if (kind_case() != kVariable) {
    return nullptr;
  }
  clear_has_kind();
  return _impl_.kind_.variable_.Release();
}
inline void Expr::set_allocated_variable(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_kind()) {
    clear_kind();
  }
  if (value != nullptr) {
    set_has_variable();
    _impl_.kind_.variable_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ez_proto.Expr.variable)
}

// .ez_proto.Expr.Call call = 4;
inline bool Expr::has_call() const {
  return kind_case() == kCall;
}
inline bool Expr::_internal_has_call() const {
  return kind_case() == kCall;
}
inline void Expr::set_has_call() {
  _impl_._oneof_case_[0] = kCall;
}
inline void Expr::clear_call() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kCall) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.call_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.call_);
    }
    clear_has_kind();
  }
}
inline ::ez_proto::Expr_Call* Expr::release_call() {
  // @@protoc_insertion_point(field_release:ez_proto.Expr.call)
  if (kind_case() == kCall) {
    clear_has_kind();
    auto* temp = _impl_.kind_.call_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.call_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ez_proto::Expr_Call& Expr::_internal_call() const {
  return kind_case() == kCall ? *_impl_.kind_.call_ : reinterpret_cast<::ez_proto::Expr_Call&>(::ez_proto::_Expr_Call_default_instance_);
}
inline const ::ez_proto::Expr_Call& Expr::call() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.Expr.call)
  return _internal_call();
}
inline ::ez_proto::Expr_Call* Expr::unsafe_arena_release_call() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ez_proto.Expr.call)
  if (kind_case() == kCall) {
    clear_has_kind();
    auto* temp = _impl_.kind_.call_;
    _impl_.kind_.call_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expr::unsafe_arena_set_allocated_call(::ez_proto::Expr_Call* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_call();
    _impl_.kind_.call_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ez_proto.Expr.call)
}
inline ::ez_proto::Expr_Call* Expr::_internal_mutable_call() {
  if (kind_case() != kCall) {
    clear_kind();
    set_has_call();
    _impl_.kind_.call_ =
        ::google::protobuf::Message::DefaultConstruct<::ez_proto::Expr_Call>(GetArena());
  }
  return _impl_.kind_.call_;
}
inline ::ez_proto::Expr_Call* Expr::mutable_call() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ez_proto::Expr_Call* _msg = _internal_mutable_call();
  // @@protoc_insertion_point(field_mutable:ez_proto.Expr.call)
  return _msg;
}

// required .ez_proto.EzType expr_type = 7;
inline bool Expr::has_expr_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.expr_type_ != nullptr);
  return value;
}
inline void Expr::clear_expr_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.expr_type_ != nullptr) _impl_.expr_type_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ez_proto::EzType& Expr::_internal_expr_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::ez_proto::EzType* p = _impl_.expr_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::ez_proto::EzType&>(::ez_proto::_EzType_default_instance_);
}
inline const ::ez_proto::EzType& Expr::expr_type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.Expr.expr_type)
  return _internal_expr_type();
}
inline void Expr::unsafe_arena_set_allocated_expr_type(::ez_proto::EzType* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.expr_type_);
  }
  _impl_.expr_type_ = reinterpret_cast<::ez_proto::EzType*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ez_proto.Expr.expr_type)
}
inline ::ez_proto::EzType* Expr::release_expr_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ez_proto::EzType* released = _impl_.expr_type_;
  _impl_.expr_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ez_proto::EzType* Expr::unsafe_arena_release_expr_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ez_proto.Expr.expr_type)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ez_proto::EzType* temp = _impl_.expr_type_;
  _impl_.expr_type_ = nullptr;
  return temp;
}
inline ::ez_proto::EzType* Expr::_internal_mutable_expr_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.expr_type_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::ez_proto::EzType>(GetArena());
    _impl_.expr_type_ = reinterpret_cast<::ez_proto::EzType*>(p);
  }
  return _impl_.expr_type_;
}
inline ::ez_proto::EzType* Expr::mutable_expr_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::ez_proto::EzType* _msg = _internal_mutable_expr_type();
  // @@protoc_insertion_point(field_mutable:ez_proto.Expr.expr_type)
  return _msg;
}
inline void Expr::set_allocated_expr_type(::ez_proto::EzType* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.expr_type_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.expr_type_ = reinterpret_cast<::ez_proto::EzType*>(value);
  // @@protoc_insertion_point(field_set_allocated:ez_proto.Expr.expr_type)
}

inline bool Expr::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void Expr::clear_has_kind() {
  _impl_._oneof_case_[0] = KIND_NOT_SET;
}
inline Expr::KindCase Expr::kind_case() const {
  return Expr::KindCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Statement_Declaration

// required string name = 1;
inline bool Statement_Declaration::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Statement_Declaration::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Statement_Declaration::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.Statement.Declaration.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Statement_Declaration::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ez_proto.Statement.Declaration.name)
}
inline std::string* Statement_Declaration::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ez_proto.Statement.Declaration.name)
  return _s;
}
inline const std::string& Statement_Declaration::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void Statement_Declaration::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Statement_Declaration::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Statement_Declaration::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ez_proto.Statement.Declaration.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Statement_Declaration::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ez_proto.Statement.Declaration.name)
}

// required .ez_proto.EzType type = 2;
inline bool Statement_Declaration::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_ != nullptr);
  return value;
}
inline void Statement_Declaration::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.type_ != nullptr) _impl_.type_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ez_proto::EzType& Statement_Declaration::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::ez_proto::EzType* p = _impl_.type_;
  return p != nullptr ? *p : reinterpret_cast<const ::ez_proto::EzType&>(::ez_proto::_EzType_default_instance_);
}
inline const ::ez_proto::EzType& Statement_Declaration::type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.Statement.Declaration.type)
  return _internal_type();
}
inline void Statement_Declaration::unsafe_arena_set_allocated_type(::ez_proto::EzType* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_);
  }
  _impl_.type_ = reinterpret_cast<::ez_proto::EzType*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ez_proto.Statement.Declaration.type)
}
inline ::ez_proto::EzType* Statement_Declaration::release_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ez_proto::EzType* released = _impl_.type_;
  _impl_.type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ez_proto::EzType* Statement_Declaration::unsafe_arena_release_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ez_proto.Statement.Declaration.type)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ez_proto::EzType* temp = _impl_.type_;
  _impl_.type_ = nullptr;
  return temp;
}
inline ::ez_proto::EzType* Statement_Declaration::_internal_mutable_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.type_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::ez_proto::EzType>(GetArena());
    _impl_.type_ = reinterpret_cast<::ez_proto::EzType*>(p);
  }
  return _impl_.type_;
}
inline ::ez_proto::EzType* Statement_Declaration::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::ez_proto::EzType* _msg = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:ez_proto.Statement.Declaration.type)
  return _msg;
}
inline void Statement_Declaration::set_allocated_type(::ez_proto::EzType* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.type_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.type_ = reinterpret_cast<::ez_proto::EzType*>(value);
  // @@protoc_insertion_point(field_set_allocated:ez_proto.Statement.Declaration.type)
}

// required .ez_proto.Expr rhs = 3;
inline bool Statement_Declaration::has_rhs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rhs_ != nullptr);
  return value;
}
inline void Statement_Declaration::clear_rhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rhs_ != nullptr) _impl_.rhs_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::ez_proto::Expr& Statement_Declaration::_internal_rhs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::ez_proto::Expr* p = _impl_.rhs_;
  return p != nullptr ? *p : reinterpret_cast<const ::ez_proto::Expr&>(::ez_proto::_Expr_default_instance_);
}
inline const ::ez_proto::Expr& Statement_Declaration::rhs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.Statement.Declaration.rhs)
  return _internal_rhs();
}
inline void Statement_Declaration::unsafe_arena_set_allocated_rhs(::ez_proto::Expr* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rhs_);
  }
  _impl_.rhs_ = reinterpret_cast<::ez_proto::Expr*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ez_proto.Statement.Declaration.rhs)
}
inline ::ez_proto::Expr* Statement_Declaration::release_rhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::ez_proto::Expr* released = _impl_.rhs_;
  _impl_.rhs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ez_proto::Expr* Statement_Declaration::unsafe_arena_release_rhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ez_proto.Statement.Declaration.rhs)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::ez_proto::Expr* temp = _impl_.rhs_;
  _impl_.rhs_ = nullptr;
  return temp;
}
inline ::ez_proto::Expr* Statement_Declaration::_internal_mutable_rhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rhs_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::ez_proto::Expr>(GetArena());
    _impl_.rhs_ = reinterpret_cast<::ez_proto::Expr*>(p);
  }
  return _impl_.rhs_;
}
inline ::ez_proto::Expr* Statement_Declaration::mutable_rhs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::ez_proto::Expr* _msg = _internal_mutable_rhs();
  // @@protoc_insertion_point(field_mutable:ez_proto.Statement.Declaration.rhs)
  return _msg;
}
inline void Statement_Declaration::set_allocated_rhs(::ez_proto::Expr* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.rhs_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.rhs_ = reinterpret_cast<::ez_proto::Expr*>(value);
  // @@protoc_insertion_point(field_set_allocated:ez_proto.Statement.Declaration.rhs)
}

// -------------------------------------------------------------------

// Statement_If

// required .ez_proto.Expr condition = 1;
inline bool Statement_If::has_condition() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.condition_ != nullptr);
  return value;
}
inline void Statement_If::clear_condition() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.condition_ != nullptr) _impl_.condition_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ez_proto::Expr& Statement_If::_internal_condition() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::ez_proto::Expr* p = _impl_.condition_;
  return p != nullptr ? *p : reinterpret_cast<const ::ez_proto::Expr&>(::ez_proto::_Expr_default_instance_);
}
inline const ::ez_proto::Expr& Statement_If::condition() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.Statement.If.condition)
  return _internal_condition();
}
inline void Statement_If::unsafe_arena_set_allocated_condition(::ez_proto::Expr* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.condition_);
  }
  _impl_.condition_ = reinterpret_cast<::ez_proto::Expr*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ez_proto.Statement.If.condition)
}
inline ::ez_proto::Expr* Statement_If::release_condition() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ez_proto::Expr* released = _impl_.condition_;
  _impl_.condition_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ez_proto::Expr* Statement_If::unsafe_arena_release_condition() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ez_proto.Statement.If.condition)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ez_proto::Expr* temp = _impl_.condition_;
  _impl_.condition_ = nullptr;
  return temp;
}
inline ::ez_proto::Expr* Statement_If::_internal_mutable_condition() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.condition_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::ez_proto::Expr>(GetArena());
    _impl_.condition_ = reinterpret_cast<::ez_proto::Expr*>(p);
  }
  return _impl_.condition_;
}
inline ::ez_proto::Expr* Statement_If::mutable_condition() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::ez_proto::Expr* _msg = _internal_mutable_condition();
  // @@protoc_insertion_point(field_mutable:ez_proto.Statement.If.condition)
  return _msg;
}
inline void Statement_If::set_allocated_condition(::ez_proto::Expr* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.condition_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.condition_ = reinterpret_cast<::ez_proto::Expr*>(value);
  // @@protoc_insertion_point(field_set_allocated:ez_proto.Statement.If.condition)
}

// required .ez_proto.Statement then_branch = 2;
inline bool Statement_If::has_then_branch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.then_branch_ != nullptr);
  return value;
}
inline void Statement_If::clear_then_branch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.then_branch_ != nullptr) _impl_.then_branch_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ez_proto::Statement& Statement_If::_internal_then_branch() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::ez_proto::Statement* p = _impl_.then_branch_;
  return p != nullptr ? *p : reinterpret_cast<const ::ez_proto::Statement&>(::ez_proto::_Statement_default_instance_);
}
inline const ::ez_proto::Statement& Statement_If::then_branch() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.Statement.If.then_branch)
  return _internal_then_branch();
}
inline void Statement_If::unsafe_arena_set_allocated_then_branch(::ez_proto::Statement* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.then_branch_);
  }
  _impl_.then_branch_ = reinterpret_cast<::ez_proto::Statement*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ez_proto.Statement.If.then_branch)
}
inline ::ez_proto::Statement* Statement_If::release_then_branch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ez_proto::Statement* released = _impl_.then_branch_;
  _impl_.then_branch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ez_proto::Statement* Statement_If::unsafe_arena_release_then_branch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ez_proto.Statement.If.then_branch)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ez_proto::Statement* temp = _impl_.then_branch_;
  _impl_.then_branch_ = nullptr;
  return temp;
}
inline ::ez_proto::Statement* Statement_If::_internal_mutable_then_branch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.then_branch_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::ez_proto::Statement>(GetArena());
    _impl_.then_branch_ = reinterpret_cast<::ez_proto::Statement*>(p);
  }
  return _impl_.then_branch_;
}
inline ::ez_proto::Statement* Statement_If::mutable_then_branch() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::ez_proto::Statement* _msg = _internal_mutable_then_branch();
  // @@protoc_insertion_point(field_mutable:ez_proto.Statement.If.then_branch)
  return _msg;
}
inline void Statement_If::set_allocated_then_branch(::ez_proto::Statement* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.then_branch_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.then_branch_ = reinterpret_cast<::ez_proto::Statement*>(value);
  // @@protoc_insertion_point(field_set_allocated:ez_proto.Statement.If.then_branch)
}

// required .ez_proto.Statement else_branch = 3;
inline bool Statement_If::has_else_branch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.else_branch_ != nullptr);
  return value;
}
inline void Statement_If::clear_else_branch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.else_branch_ != nullptr) _impl_.else_branch_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::ez_proto::Statement& Statement_If::_internal_else_branch() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::ez_proto::Statement* p = _impl_.else_branch_;
  return p != nullptr ? *p : reinterpret_cast<const ::ez_proto::Statement&>(::ez_proto::_Statement_default_instance_);
}
inline const ::ez_proto::Statement& Statement_If::else_branch() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.Statement.If.else_branch)
  return _internal_else_branch();
}
inline void Statement_If::unsafe_arena_set_allocated_else_branch(::ez_proto::Statement* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.else_branch_);
  }
  _impl_.else_branch_ = reinterpret_cast<::ez_proto::Statement*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ez_proto.Statement.If.else_branch)
}
inline ::ez_proto::Statement* Statement_If::release_else_branch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::ez_proto::Statement* released = _impl_.else_branch_;
  _impl_.else_branch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ez_proto::Statement* Statement_If::unsafe_arena_release_else_branch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ez_proto.Statement.If.else_branch)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::ez_proto::Statement* temp = _impl_.else_branch_;
  _impl_.else_branch_ = nullptr;
  return temp;
}
inline ::ez_proto::Statement* Statement_If::_internal_mutable_else_branch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.else_branch_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::ez_proto::Statement>(GetArena());
    _impl_.else_branch_ = reinterpret_cast<::ez_proto::Statement*>(p);
  }
  return _impl_.else_branch_;
}
inline ::ez_proto::Statement* Statement_If::mutable_else_branch() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::ez_proto::Statement* _msg = _internal_mutable_else_branch();
  // @@protoc_insertion_point(field_mutable:ez_proto.Statement.If.else_branch)
  return _msg;
}
inline void Statement_If::set_allocated_else_branch(::ez_proto::Statement* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.else_branch_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.else_branch_ = reinterpret_cast<::ez_proto::Statement*>(value);
  // @@protoc_insertion_point(field_set_allocated:ez_proto.Statement.If.else_branch)
}

// -------------------------------------------------------------------

// Statement_Block

// repeated .ez_proto.Statement statements = 1;
inline int Statement_Block::_internal_statements_size() const {
  return _internal_statements().size();
}
inline int Statement_Block::statements_size() const {
  return _internal_statements_size();
}
inline void Statement_Block::clear_statements() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.statements_.Clear();
}
inline ::ez_proto::Statement* Statement_Block::mutable_statements(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ez_proto.Statement.Block.statements)
  return _internal_mutable_statements()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::ez_proto::Statement>* Statement_Block::mutable_statements()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ez_proto.Statement.Block.statements)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_statements();
}
inline const ::ez_proto::Statement& Statement_Block::statements(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.Statement.Block.statements)
  return _internal_statements().Get(index);
}
inline ::ez_proto::Statement* Statement_Block::add_statements() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::ez_proto::Statement* _add = _internal_mutable_statements()->Add();
  // @@protoc_insertion_point(field_add:ez_proto.Statement.Block.statements)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::ez_proto::Statement>& Statement_Block::statements() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ez_proto.Statement.Block.statements)
  return _internal_statements();
}
inline const ::google::protobuf::RepeatedPtrField<::ez_proto::Statement>&
Statement_Block::_internal_statements() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.statements_;
}
inline ::google::protobuf::RepeatedPtrField<::ez_proto::Statement>*
Statement_Block::_internal_mutable_statements() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.statements_;
}

// -------------------------------------------------------------------

// Statement_While

// required .ez_proto.Expr condition = 1;
inline bool Statement_While::has_condition() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.condition_ != nullptr);
  return value;
}
inline void Statement_While::clear_condition() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.condition_ != nullptr) _impl_.condition_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ez_proto::Expr& Statement_While::_internal_condition() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::ez_proto::Expr* p = _impl_.condition_;
  return p != nullptr ? *p : reinterpret_cast<const ::ez_proto::Expr&>(::ez_proto::_Expr_default_instance_);
}
inline const ::ez_proto::Expr& Statement_While::condition() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.Statement.While.condition)
  return _internal_condition();
}
inline void Statement_While::unsafe_arena_set_allocated_condition(::ez_proto::Expr* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.condition_);
  }
  _impl_.condition_ = reinterpret_cast<::ez_proto::Expr*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ez_proto.Statement.While.condition)
}
inline ::ez_proto::Expr* Statement_While::release_condition() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ez_proto::Expr* released = _impl_.condition_;
  _impl_.condition_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ez_proto::Expr* Statement_While::unsafe_arena_release_condition() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ez_proto.Statement.While.condition)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ez_proto::Expr* temp = _impl_.condition_;
  _impl_.condition_ = nullptr;
  return temp;
}
inline ::ez_proto::Expr* Statement_While::_internal_mutable_condition() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.condition_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::ez_proto::Expr>(GetArena());
    _impl_.condition_ = reinterpret_cast<::ez_proto::Expr*>(p);
  }
  return _impl_.condition_;
}
inline ::ez_proto::Expr* Statement_While::mutable_condition() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::ez_proto::Expr* _msg = _internal_mutable_condition();
  // @@protoc_insertion_point(field_mutable:ez_proto.Statement.While.condition)
  return _msg;
}
inline void Statement_While::set_allocated_condition(::ez_proto::Expr* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.condition_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.condition_ = reinterpret_cast<::ez_proto::Expr*>(value);
  // @@protoc_insertion_point(field_set_allocated:ez_proto.Statement.While.condition)
}

// required .ez_proto.Statement body = 2;
inline bool Statement_While::has_body() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.body_ != nullptr);
  return value;
}
inline void Statement_While::clear_body() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.body_ != nullptr) _impl_.body_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ez_proto::Statement& Statement_While::_internal_body() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::ez_proto::Statement* p = _impl_.body_;
  return p != nullptr ? *p : reinterpret_cast<const ::ez_proto::Statement&>(::ez_proto::_Statement_default_instance_);
}
inline const ::ez_proto::Statement& Statement_While::body() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.Statement.While.body)
  return _internal_body();
}
inline void Statement_While::unsafe_arena_set_allocated_body(::ez_proto::Statement* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.body_);
  }
  _impl_.body_ = reinterpret_cast<::ez_proto::Statement*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ez_proto.Statement.While.body)
}
inline ::ez_proto::Statement* Statement_While::release_body() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ez_proto::Statement* released = _impl_.body_;
  _impl_.body_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ez_proto::Statement* Statement_While::unsafe_arena_release_body() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ez_proto.Statement.While.body)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ez_proto::Statement* temp = _impl_.body_;
  _impl_.body_ = nullptr;
  return temp;
}
inline ::ez_proto::Statement* Statement_While::_internal_mutable_body() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.body_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::ez_proto::Statement>(GetArena());
    _impl_.body_ = reinterpret_cast<::ez_proto::Statement*>(p);
  }
  return _impl_.body_;
}
inline ::ez_proto::Statement* Statement_While::mutable_body() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::ez_proto::Statement* _msg = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:ez_proto.Statement.While.body)
  return _msg;
}
inline void Statement_While::set_allocated_body(::ez_proto::Statement* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.body_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.body_ = reinterpret_cast<::ez_proto::Statement*>(value);
  // @@protoc_insertion_point(field_set_allocated:ez_proto.Statement.While.body)
}

// -------------------------------------------------------------------

// Statement_Assign

// required string name = 1;
inline bool Statement_Assign::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Statement_Assign::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Statement_Assign::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.Statement.Assign.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Statement_Assign::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ez_proto.Statement.Assign.name)
}
inline std::string* Statement_Assign::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ez_proto.Statement.Assign.name)
  return _s;
}
inline const std::string& Statement_Assign::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void Statement_Assign::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Statement_Assign::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Statement_Assign::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ez_proto.Statement.Assign.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Statement_Assign::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ez_proto.Statement.Assign.name)
}

// required .ez_proto.Expr rhs = 2;
inline bool Statement_Assign::has_rhs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rhs_ != nullptr);
  return value;
}
inline void Statement_Assign::clear_rhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rhs_ != nullptr) _impl_.rhs_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ez_proto::Expr& Statement_Assign::_internal_rhs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::ez_proto::Expr* p = _impl_.rhs_;
  return p != nullptr ? *p : reinterpret_cast<const ::ez_proto::Expr&>(::ez_proto::_Expr_default_instance_);
}
inline const ::ez_proto::Expr& Statement_Assign::rhs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.Statement.Assign.rhs)
  return _internal_rhs();
}
inline void Statement_Assign::unsafe_arena_set_allocated_rhs(::ez_proto::Expr* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rhs_);
  }
  _impl_.rhs_ = reinterpret_cast<::ez_proto::Expr*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ez_proto.Statement.Assign.rhs)
}
inline ::ez_proto::Expr* Statement_Assign::release_rhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ez_proto::Expr* released = _impl_.rhs_;
  _impl_.rhs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ez_proto::Expr* Statement_Assign::unsafe_arena_release_rhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ez_proto.Statement.Assign.rhs)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ez_proto::Expr* temp = _impl_.rhs_;
  _impl_.rhs_ = nullptr;
  return temp;
}
inline ::ez_proto::Expr* Statement_Assign::_internal_mutable_rhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rhs_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::ez_proto::Expr>(GetArena());
    _impl_.rhs_ = reinterpret_cast<::ez_proto::Expr*>(p);
  }
  return _impl_.rhs_;
}
inline ::ez_proto::Expr* Statement_Assign::mutable_rhs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::ez_proto::Expr* _msg = _internal_mutable_rhs();
  // @@protoc_insertion_point(field_mutable:ez_proto.Statement.Assign.rhs)
  return _msg;
}
inline void Statement_Assign::set_allocated_rhs(::ez_proto::Expr* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.rhs_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.rhs_ = reinterpret_cast<::ez_proto::Expr*>(value);
  // @@protoc_insertion_point(field_set_allocated:ez_proto.Statement.Assign.rhs)
}

// -------------------------------------------------------------------

// Statement

// .ez_proto.Expr expr = 1;
inline bool Statement::has_expr() const {
  return kind_case() == kExpr;
}
inline bool Statement::_internal_has_expr() const {
  return kind_case() == kExpr;
}
inline void Statement::set_has_expr() {
  _impl_._oneof_case_[0] = kExpr;
}
inline void Statement::clear_expr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kExpr) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.expr_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.expr_);
    }
    clear_has_kind();
  }
}
inline ::ez_proto::Expr* Statement::release_expr() {
  // @@protoc_insertion_point(field_release:ez_proto.Statement.expr)
  if (kind_case() == kExpr) {
    clear_has_kind();
    auto* temp = _impl_.kind_.expr_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ez_proto::Expr& Statement::_internal_expr() const {
  return kind_case() == kExpr ? *_impl_.kind_.expr_ : reinterpret_cast<::ez_proto::Expr&>(::ez_proto::_Expr_default_instance_);
}
inline const ::ez_proto::Expr& Statement::expr() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.Statement.expr)
  return _internal_expr();
}
inline ::ez_proto::Expr* Statement::unsafe_arena_release_expr() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ez_proto.Statement.expr)
  if (kind_case() == kExpr) {
    clear_has_kind();
    auto* temp = _impl_.kind_.expr_;
    _impl_.kind_.expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Statement::unsafe_arena_set_allocated_expr(::ez_proto::Expr* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_expr();
    _impl_.kind_.expr_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ez_proto.Statement.expr)
}
inline ::ez_proto::Expr* Statement::_internal_mutable_expr() {
  if (kind_case() != kExpr) {
    clear_kind();
    set_has_expr();
    _impl_.kind_.expr_ =
        ::google::protobuf::Message::DefaultConstruct<::ez_proto::Expr>(GetArena());
  }
  return _impl_.kind_.expr_;
}
inline ::ez_proto::Expr* Statement::mutable_expr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ez_proto::Expr* _msg = _internal_mutable_expr();
  // @@protoc_insertion_point(field_mutable:ez_proto.Statement.expr)
  return _msg;
}

// .ez_proto.Statement.Declaration declaration = 2;
inline bool Statement::has_declaration() const {
  return kind_case() == kDeclaration;
}
inline bool Statement::_internal_has_declaration() const {
  return kind_case() == kDeclaration;
}
inline void Statement::set_has_declaration() {
  _impl_._oneof_case_[0] = kDeclaration;
}
inline void Statement::clear_declaration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kDeclaration) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.declaration_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.declaration_);
    }
    clear_has_kind();
  }
}
inline ::ez_proto::Statement_Declaration* Statement::release_declaration() {
  // @@protoc_insertion_point(field_release:ez_proto.Statement.declaration)
  if (kind_case() == kDeclaration) {
    clear_has_kind();
    auto* temp = _impl_.kind_.declaration_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.declaration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ez_proto::Statement_Declaration& Statement::_internal_declaration() const {
  return kind_case() == kDeclaration ? *_impl_.kind_.declaration_ : reinterpret_cast<::ez_proto::Statement_Declaration&>(::ez_proto::_Statement_Declaration_default_instance_);
}
inline const ::ez_proto::Statement_Declaration& Statement::declaration() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.Statement.declaration)
  return _internal_declaration();
}
inline ::ez_proto::Statement_Declaration* Statement::unsafe_arena_release_declaration() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ez_proto.Statement.declaration)
  if (kind_case() == kDeclaration) {
    clear_has_kind();
    auto* temp = _impl_.kind_.declaration_;
    _impl_.kind_.declaration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Statement::unsafe_arena_set_allocated_declaration(::ez_proto::Statement_Declaration* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_declaration();
    _impl_.kind_.declaration_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ez_proto.Statement.declaration)
}
inline ::ez_proto::Statement_Declaration* Statement::_internal_mutable_declaration() {
  if (kind_case() != kDeclaration) {
    clear_kind();
    set_has_declaration();
    _impl_.kind_.declaration_ =
        ::google::protobuf::Message::DefaultConstruct<::ez_proto::Statement_Declaration>(GetArena());
  }
  return _impl_.kind_.declaration_;
}
inline ::ez_proto::Statement_Declaration* Statement::mutable_declaration() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ez_proto::Statement_Declaration* _msg = _internal_mutable_declaration();
  // @@protoc_insertion_point(field_mutable:ez_proto.Statement.declaration)
  return _msg;
}

// .ez_proto.Statement.If if = 3;
inline bool Statement::has_if_() const {
  return kind_case() == kIf;
}
inline bool Statement::_internal_has_if_() const {
  return kind_case() == kIf;
}
inline void Statement::set_has_if_() {
  _impl_._oneof_case_[0] = kIf;
}
inline void Statement::clear_if_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kIf) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.if__;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.if__);
    }
    clear_has_kind();
  }
}
inline ::ez_proto::Statement_If* Statement::release_if_() {
  // @@protoc_insertion_point(field_release:ez_proto.Statement.if)
  if (kind_case() == kIf) {
    clear_has_kind();
    auto* temp = _impl_.kind_.if__;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.if__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ez_proto::Statement_If& Statement::_internal_if_() const {
  return kind_case() == kIf ? *_impl_.kind_.if__ : reinterpret_cast<::ez_proto::Statement_If&>(::ez_proto::_Statement_If_default_instance_);
}
inline const ::ez_proto::Statement_If& Statement::if_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.Statement.if)
  return _internal_if_();
}
inline ::ez_proto::Statement_If* Statement::unsafe_arena_release_if_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ez_proto.Statement.if)
  if (kind_case() == kIf) {
    clear_has_kind();
    auto* temp = _impl_.kind_.if__;
    _impl_.kind_.if__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Statement::unsafe_arena_set_allocated_if_(::ez_proto::Statement_If* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_if_();
    _impl_.kind_.if__ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ez_proto.Statement.if)
}
inline ::ez_proto::Statement_If* Statement::_internal_mutable_if_() {
  if (kind_case() != kIf) {
    clear_kind();
    set_has_if_();
    _impl_.kind_.if__ =
        ::google::protobuf::Message::DefaultConstruct<::ez_proto::Statement_If>(GetArena());
  }
  return _impl_.kind_.if__;
}
inline ::ez_proto::Statement_If* Statement::mutable_if_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ez_proto::Statement_If* _msg = _internal_mutable_if_();
  // @@protoc_insertion_point(field_mutable:ez_proto.Statement.if)
  return _msg;
}

// .ez_proto.Statement.Block block = 4;
inline bool Statement::has_block() const {
  return kind_case() == kBlock;
}
inline bool Statement::_internal_has_block() const {
  return kind_case() == kBlock;
}
inline void Statement::set_has_block() {
  _impl_._oneof_case_[0] = kBlock;
}
inline void Statement::clear_block() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kBlock) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.block_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.block_);
    }
    clear_has_kind();
  }
}
inline ::ez_proto::Statement_Block* Statement::release_block() {
  // @@protoc_insertion_point(field_release:ez_proto.Statement.block)
  if (kind_case() == kBlock) {
    clear_has_kind();
    auto* temp = _impl_.kind_.block_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ez_proto::Statement_Block& Statement::_internal_block() const {
  return kind_case() == kBlock ? *_impl_.kind_.block_ : reinterpret_cast<::ez_proto::Statement_Block&>(::ez_proto::_Statement_Block_default_instance_);
}
inline const ::ez_proto::Statement_Block& Statement::block() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.Statement.block)
  return _internal_block();
}
inline ::ez_proto::Statement_Block* Statement::unsafe_arena_release_block() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ez_proto.Statement.block)
  if (kind_case() == kBlock) {
    clear_has_kind();
    auto* temp = _impl_.kind_.block_;
    _impl_.kind_.block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Statement::unsafe_arena_set_allocated_block(::ez_proto::Statement_Block* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_block();
    _impl_.kind_.block_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ez_proto.Statement.block)
}
inline ::ez_proto::Statement_Block* Statement::_internal_mutable_block() {
  if (kind_case() != kBlock) {
    clear_kind();
    set_has_block();
    _impl_.kind_.block_ =
        ::google::protobuf::Message::DefaultConstruct<::ez_proto::Statement_Block>(GetArena());
  }
  return _impl_.kind_.block_;
}
inline ::ez_proto::Statement_Block* Statement::mutable_block() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ez_proto::Statement_Block* _msg = _internal_mutable_block();
  // @@protoc_insertion_point(field_mutable:ez_proto.Statement.block)
  return _msg;
}

// .ez_proto.Statement.While while = 5;
inline bool Statement::has_while_() const {
  return kind_case() == kWhile;
}
inline bool Statement::_internal_has_while_() const {
  return kind_case() == kWhile;
}
inline void Statement::set_has_while_() {
  _impl_._oneof_case_[0] = kWhile;
}
inline void Statement::clear_while_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kWhile) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.while__;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.while__);
    }
    clear_has_kind();
  }
}
inline ::ez_proto::Statement_While* Statement::release_while_() {
  // @@protoc_insertion_point(field_release:ez_proto.Statement.while)
  if (kind_case() == kWhile) {
    clear_has_kind();
    auto* temp = _impl_.kind_.while__;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.while__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ez_proto::Statement_While& Statement::_internal_while_() const {
  return kind_case() == kWhile ? *_impl_.kind_.while__ : reinterpret_cast<::ez_proto::Statement_While&>(::ez_proto::_Statement_While_default_instance_);
}
inline const ::ez_proto::Statement_While& Statement::while_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.Statement.while)
  return _internal_while_();
}
inline ::ez_proto::Statement_While* Statement::unsafe_arena_release_while_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ez_proto.Statement.while)
  if (kind_case() == kWhile) {
    clear_has_kind();
    auto* temp = _impl_.kind_.while__;
    _impl_.kind_.while__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Statement::unsafe_arena_set_allocated_while_(::ez_proto::Statement_While* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_while_();
    _impl_.kind_.while__ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ez_proto.Statement.while)
}
inline ::ez_proto::Statement_While* Statement::_internal_mutable_while_() {
  if (kind_case() != kWhile) {
    clear_kind();
    set_has_while_();
    _impl_.kind_.while__ =
        ::google::protobuf::Message::DefaultConstruct<::ez_proto::Statement_While>(GetArena());
  }
  return _impl_.kind_.while__;
}
inline ::ez_proto::Statement_While* Statement::mutable_while_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ez_proto::Statement_While* _msg = _internal_mutable_while_();
  // @@protoc_insertion_point(field_mutable:ez_proto.Statement.while)
  return _msg;
}

// .ez_proto.Expr return = 6;
inline bool Statement::has_return_() const {
  return kind_case() == kReturn;
}
inline bool Statement::_internal_has_return_() const {
  return kind_case() == kReturn;
}
inline void Statement::set_has_return_() {
  _impl_._oneof_case_[0] = kReturn;
}
inline void Statement::clear_return_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kReturn) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.return__;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.return__);
    }
    clear_has_kind();
  }
}
inline ::ez_proto::Expr* Statement::release_return_() {
  // @@protoc_insertion_point(field_release:ez_proto.Statement.return)
  if (kind_case() == kReturn) {
    clear_has_kind();
    auto* temp = _impl_.kind_.return__;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.return__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ez_proto::Expr& Statement::_internal_return_() const {
  return kind_case() == kReturn ? *_impl_.kind_.return__ : reinterpret_cast<::ez_proto::Expr&>(::ez_proto::_Expr_default_instance_);
}
inline const ::ez_proto::Expr& Statement::return_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.Statement.return)
  return _internal_return_();
}
inline ::ez_proto::Expr* Statement::unsafe_arena_release_return_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ez_proto.Statement.return)
  if (kind_case() == kReturn) {
    clear_has_kind();
    auto* temp = _impl_.kind_.return__;
    _impl_.kind_.return__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Statement::unsafe_arena_set_allocated_return_(::ez_proto::Expr* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_return_();
    _impl_.kind_.return__ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ez_proto.Statement.return)
}
inline ::ez_proto::Expr* Statement::_internal_mutable_return_() {
  if (kind_case() != kReturn) {
    clear_kind();
    set_has_return_();
    _impl_.kind_.return__ =
        ::google::protobuf::Message::DefaultConstruct<::ez_proto::Expr>(GetArena());
  }
  return _impl_.kind_.return__;
}
inline ::ez_proto::Expr* Statement::mutable_return_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ez_proto::Expr* _msg = _internal_mutable_return_();
  // @@protoc_insertion_point(field_mutable:ez_proto.Statement.return)
  return _msg;
}

// .ez_proto.Statement.Assign assign = 7;
inline bool Statement::has_assign() const {
  return kind_case() == kAssign;
}
inline bool Statement::_internal_has_assign() const {
  return kind_case() == kAssign;
}
inline void Statement::set_has_assign() {
  _impl_._oneof_case_[0] = kAssign;
}
inline void Statement::clear_assign() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kAssign) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.assign_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.assign_);
    }
    clear_has_kind();
  }
}
inline ::ez_proto::Statement_Assign* Statement::release_assign() {
  // @@protoc_insertion_point(field_release:ez_proto.Statement.assign)
  if (kind_case() == kAssign) {
    clear_has_kind();
    auto* temp = _impl_.kind_.assign_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.assign_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ez_proto::Statement_Assign& Statement::_internal_assign() const {
  return kind_case() == kAssign ? *_impl_.kind_.assign_ : reinterpret_cast<::ez_proto::Statement_Assign&>(::ez_proto::_Statement_Assign_default_instance_);
}
inline const ::ez_proto::Statement_Assign& Statement::assign() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.Statement.assign)
  return _internal_assign();
}
inline ::ez_proto::Statement_Assign* Statement::unsafe_arena_release_assign() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ez_proto.Statement.assign)
  if (kind_case() == kAssign) {
    clear_has_kind();
    auto* temp = _impl_.kind_.assign_;
    _impl_.kind_.assign_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Statement::unsafe_arena_set_allocated_assign(::ez_proto::Statement_Assign* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_assign();
    _impl_.kind_.assign_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ez_proto.Statement.assign)
}
inline ::ez_proto::Statement_Assign* Statement::_internal_mutable_assign() {
  if (kind_case() != kAssign) {
    clear_kind();
    set_has_assign();
    _impl_.kind_.assign_ =
        ::google::protobuf::Message::DefaultConstruct<::ez_proto::Statement_Assign>(GetArena());
  }
  return _impl_.kind_.assign_;
}
inline ::ez_proto::Statement_Assign* Statement::mutable_assign() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ez_proto::Statement_Assign* _msg = _internal_mutable_assign();
  // @@protoc_insertion_point(field_mutable:ez_proto.Statement.assign)
  return _msg;
}

inline bool Statement::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void Statement::clear_has_kind() {
  _impl_._oneof_case_[0] = KIND_NOT_SET;
}
inline Statement::KindCase Statement::kind_case() const {
  return Statement::KindCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Definition_EzTypedParam

// required .ez_proto.EzType param_type = 1;
inline bool Definition_EzTypedParam::has_param_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.param_type_ != nullptr);
  return value;
}
inline void Definition_EzTypedParam::clear_param_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.param_type_ != nullptr) _impl_.param_type_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ez_proto::EzType& Definition_EzTypedParam::_internal_param_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::ez_proto::EzType* p = _impl_.param_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::ez_proto::EzType&>(::ez_proto::_EzType_default_instance_);
}
inline const ::ez_proto::EzType& Definition_EzTypedParam::param_type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.Definition.EzTypedParam.param_type)
  return _internal_param_type();
}
inline void Definition_EzTypedParam::unsafe_arena_set_allocated_param_type(::ez_proto::EzType* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.param_type_);
  }
  _impl_.param_type_ = reinterpret_cast<::ez_proto::EzType*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ez_proto.Definition.EzTypedParam.param_type)
}
inline ::ez_proto::EzType* Definition_EzTypedParam::release_param_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ez_proto::EzType* released = _impl_.param_type_;
  _impl_.param_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ez_proto::EzType* Definition_EzTypedParam::unsafe_arena_release_param_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ez_proto.Definition.EzTypedParam.param_type)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ez_proto::EzType* temp = _impl_.param_type_;
  _impl_.param_type_ = nullptr;
  return temp;
}
inline ::ez_proto::EzType* Definition_EzTypedParam::_internal_mutable_param_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.param_type_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::ez_proto::EzType>(GetArena());
    _impl_.param_type_ = reinterpret_cast<::ez_proto::EzType*>(p);
  }
  return _impl_.param_type_;
}
inline ::ez_proto::EzType* Definition_EzTypedParam::mutable_param_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::ez_proto::EzType* _msg = _internal_mutable_param_type();
  // @@protoc_insertion_point(field_mutable:ez_proto.Definition.EzTypedParam.param_type)
  return _msg;
}
inline void Definition_EzTypedParam::set_allocated_param_type(::ez_proto::EzType* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.param_type_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.param_type_ = reinterpret_cast<::ez_proto::EzType*>(value);
  // @@protoc_insertion_point(field_set_allocated:ez_proto.Definition.EzTypedParam.param_type)
}

// required string name = 2;
inline bool Definition_EzTypedParam::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Definition_EzTypedParam::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Definition_EzTypedParam::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.Definition.EzTypedParam.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Definition_EzTypedParam::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ez_proto.Definition.EzTypedParam.name)
}
inline std::string* Definition_EzTypedParam::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ez_proto.Definition.EzTypedParam.name)
  return _s;
}
inline const std::string& Definition_EzTypedParam::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void Definition_EzTypedParam::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Definition_EzTypedParam::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Definition_EzTypedParam::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ez_proto.Definition.EzTypedParam.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Definition_EzTypedParam::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ez_proto.Definition.EzTypedParam.name)
}

// -------------------------------------------------------------------

// Definition

// required .ez_proto.EzType return_type = 1;
inline bool Definition::has_return_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.return_type_ != nullptr);
  return value;
}
inline void Definition::clear_return_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.return_type_ != nullptr) _impl_.return_type_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ez_proto::EzType& Definition::_internal_return_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::ez_proto::EzType* p = _impl_.return_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::ez_proto::EzType&>(::ez_proto::_EzType_default_instance_);
}
inline const ::ez_proto::EzType& Definition::return_type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.Definition.return_type)
  return _internal_return_type();
}
inline void Definition::unsafe_arena_set_allocated_return_type(::ez_proto::EzType* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.return_type_);
  }
  _impl_.return_type_ = reinterpret_cast<::ez_proto::EzType*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ez_proto.Definition.return_type)
}
inline ::ez_proto::EzType* Definition::release_return_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ez_proto::EzType* released = _impl_.return_type_;
  _impl_.return_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ez_proto::EzType* Definition::unsafe_arena_release_return_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ez_proto.Definition.return_type)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ez_proto::EzType* temp = _impl_.return_type_;
  _impl_.return_type_ = nullptr;
  return temp;
}
inline ::ez_proto::EzType* Definition::_internal_mutable_return_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.return_type_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::ez_proto::EzType>(GetArena());
    _impl_.return_type_ = reinterpret_cast<::ez_proto::EzType*>(p);
  }
  return _impl_.return_type_;
}
inline ::ez_proto::EzType* Definition::mutable_return_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::ez_proto::EzType* _msg = _internal_mutable_return_type();
  // @@protoc_insertion_point(field_mutable:ez_proto.Definition.return_type)
  return _msg;
}
inline void Definition::set_allocated_return_type(::ez_proto::EzType* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.return_type_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.return_type_ = reinterpret_cast<::ez_proto::EzType*>(value);
  // @@protoc_insertion_point(field_set_allocated:ez_proto.Definition.return_type)
}

// required string name = 2;
inline bool Definition::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Definition::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Definition::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.Definition.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Definition::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ez_proto.Definition.name)
}
inline std::string* Definition::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ez_proto.Definition.name)
  return _s;
}
inline const std::string& Definition::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void Definition::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Definition::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Definition::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ez_proto.Definition.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Definition::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ez_proto.Definition.name)
}

// repeated .ez_proto.Definition.EzTypedParam params = 3;
inline int Definition::_internal_params_size() const {
  return _internal_params().size();
}
inline int Definition::params_size() const {
  return _internal_params_size();
}
inline void Definition::clear_params() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.params_.Clear();
}
inline ::ez_proto::Definition_EzTypedParam* Definition::mutable_params(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ez_proto.Definition.params)
  return _internal_mutable_params()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::ez_proto::Definition_EzTypedParam>* Definition::mutable_params()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ez_proto.Definition.params)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_params();
}
inline const ::ez_proto::Definition_EzTypedParam& Definition::params(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.Definition.params)
  return _internal_params().Get(index);
}
inline ::ez_proto::Definition_EzTypedParam* Definition::add_params() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::ez_proto::Definition_EzTypedParam* _add = _internal_mutable_params()->Add();
  // @@protoc_insertion_point(field_add:ez_proto.Definition.params)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::ez_proto::Definition_EzTypedParam>& Definition::params() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ez_proto.Definition.params)
  return _internal_params();
}
inline const ::google::protobuf::RepeatedPtrField<::ez_proto::Definition_EzTypedParam>&
Definition::_internal_params() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.params_;
}
inline ::google::protobuf::RepeatedPtrField<::ez_proto::Definition_EzTypedParam>*
Definition::_internal_mutable_params() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.params_;
}

// required .ez_proto.Statement body = 4;
inline bool Definition::has_body() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.body_ != nullptr);
  return value;
}
inline void Definition::clear_body() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.body_ != nullptr) _impl_.body_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::ez_proto::Statement& Definition::_internal_body() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::ez_proto::Statement* p = _impl_.body_;
  return p != nullptr ? *p : reinterpret_cast<const ::ez_proto::Statement&>(::ez_proto::_Statement_default_instance_);
}
inline const ::ez_proto::Statement& Definition::body() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.Definition.body)
  return _internal_body();
}
inline void Definition::unsafe_arena_set_allocated_body(::ez_proto::Statement* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.body_);
  }
  _impl_.body_ = reinterpret_cast<::ez_proto::Statement*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ez_proto.Definition.body)
}
inline ::ez_proto::Statement* Definition::release_body() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::ez_proto::Statement* released = _impl_.body_;
  _impl_.body_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ez_proto::Statement* Definition::unsafe_arena_release_body() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ez_proto.Definition.body)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::ez_proto::Statement* temp = _impl_.body_;
  _impl_.body_ = nullptr;
  return temp;
}
inline ::ez_proto::Statement* Definition::_internal_mutable_body() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.body_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::ez_proto::Statement>(GetArena());
    _impl_.body_ = reinterpret_cast<::ez_proto::Statement*>(p);
  }
  return _impl_.body_;
}
inline ::ez_proto::Statement* Definition::mutable_body() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::ez_proto::Statement* _msg = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:ez_proto.Definition.body)
  return _msg;
}
inline void Definition::set_allocated_body(::ez_proto::Statement* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.body_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.body_ = reinterpret_cast<::ez_proto::Statement*>(value);
  // @@protoc_insertion_point(field_set_allocated:ez_proto.Definition.body)
}

// -------------------------------------------------------------------

// Program

// repeated .ez_proto.Definition definitions = 1;
inline int Program::_internal_definitions_size() const {
  return _internal_definitions().size();
}
inline int Program::definitions_size() const {
  return _internal_definitions_size();
}
inline void Program::clear_definitions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.definitions_.Clear();
}
inline ::ez_proto::Definition* Program::mutable_definitions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ez_proto.Program.definitions)
  return _internal_mutable_definitions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::ez_proto::Definition>* Program::mutable_definitions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ez_proto.Program.definitions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_definitions();
}
inline const ::ez_proto::Definition& Program::definitions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ez_proto.Program.definitions)
  return _internal_definitions().Get(index);
}
inline ::ez_proto::Definition* Program::add_definitions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::ez_proto::Definition* _add = _internal_mutable_definitions()->Add();
  // @@protoc_insertion_point(field_add:ez_proto.Program.definitions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::ez_proto::Definition>& Program::definitions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ez_proto.Program.definitions)
  return _internal_definitions();
}
inline const ::google::protobuf::RepeatedPtrField<::ez_proto::Definition>&
Program::_internal_definitions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.definitions_;
}
inline ::google::protobuf::RepeatedPtrField<::ez_proto::Definition>*
Program::_internal_mutable_definitions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.definitions_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace ez_proto


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::ez_proto::EzType_NonPtr> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ez_proto::EzType_NonPtr>() {
  return ::ez_proto::EzType_NonPtr_descriptor();
}
template <>
struct is_proto_enum<::ez_proto::Expr_Binary_BinOp> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ez_proto::Expr_Binary_BinOp>() {
  return ::ez_proto::Expr_Binary_BinOp_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_ez_5fir_2eproto_2epb_2eh
