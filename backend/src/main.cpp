#include <cstdio>
#include <exception>
#include <fstream>
#include <ios>
#include <iostream>
#include <iterator>
#include <memory>
#include <stdexcept>

#include <argparse/argparse.hpp>

#include "ez_ir.pb.h"
#include "ir_visitor.hpp"
#include "objgen.hpp"
#include "optimizer.hpp"

int main(int argc, char **argv) {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  argparse::ArgumentParser parser("ezback");
  parser.add_argument("source").help(
      "The Protocobuffer file containing IR generated by frontend");
  parser.add_argument("output").help(
      "The path where ezback should generate an object file");

  try {
    parser.parse_args(argc, argv);
  } catch (const std::exception &err) {
    std::cerr << err.what() << std::endl;
    std::cerr << parser;
    std::exit(1);
  }

  auto source = parser.get<std::string>("source");
  auto output = parser.get<std::string>("output");

  std::shared_ptr<LLVMContext> ctx = std::make_shared<LLVMContext>();
  std::shared_ptr<Module> mod = std::make_shared<Module>("JIT", *ctx);

  ez_proto::Program program;
  {
    std::fstream input(source, std::ios::in | std::ios::binary);
    if (!program.ParseFromIstream(&input)) {
      printf("Failed to parse IRPB file.");
      return -1;
    }

    CodegenVisitor visitor(ctx, mod);
    for (auto def : program.definitions()) {
      switch (def.kind_case()) {
      case ez_proto::Definition::kFunc: {
        auto func = def.func();
        Function *cur_fn = visitor.codegen(func);
        // Recreate an optimizer is needed
        // https://discourse.llvm.org/t/segmentation-faults-running-the-new-llvm-modulepassmanager-with-default-pipeline
        Optimizer optimizer(ctx, mod);
        optimizer.run_on_function(cur_fn);
        break;
      }
      case ez_proto::Definition::kExtern: {
        auto extern_fn = def.extern_();
        Function *cur_fn = visitor.codegen(extern_fn);
        break;
      }
      default:
        throw std::domain_error("invalid definition");
      }
    }
    printf("Emitted LLVM IR:\n");
    fflush(stdout);
    mod->print(outs(), nullptr);

    Objgen objgen(mod);
    return objgen.generate_object(output.c_str());
  }
}
